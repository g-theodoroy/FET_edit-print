<!-- 

This "program" was created in February 2025 by
    George Theodoroy
    g.theodoroy[at]gmail.com 

It is provided as is under "MIT License"
    https://opensource.org/license/mit

-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FET - edit + print</title>
    <style>
        :root {
            --tile-width: 30px;
            --padding: 0.75px;
            --margin: 0.75px;
            --font-size: 16px;
            --body-y-margin: 30px;
        }

        body {
            font-family: Arial, sans-serif;
            font-size: var(--font-size);
            font-weight: normal;
            margin-top: var(--body-y-margin);
            margin-bottom: var(--body-y-margin);
        }

        .container {
            background-color: #f5fbff;
            color: #11496e;
            height: 230px;
            width: 500px;
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #2b375e;
            border-radius: 10px;
            text-align: center;
        }

        h1 {
            margin-top: 50px;
            font-size: 45px;
        }

        table {
            border-collapse: collapse;
            margin-top: 25px;
        }

        th,
        td {
            border: 1px solid black;
            padding-bottom: var(--padding);
            padding-left: var(--padding);
            padding-right: var(--padding);
            margin-bottom: var(--margin);
            --mf: 2;
            min-width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * var(--mf))));
        }

        td.hour {
            --mf: 2;
            max-width: calc(var(--tile-width) + var(--padding) * var(--mf) + var(--margin) * (var(--mf) + 1));
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        td.program {
            --mf: 2;
            max-width: calc(var(--tile-width) + var(--padding) * var(--mf) + var(--margin) * (var(--mf) + 1));
        }

        td.text-center {
            text-align: center;
        }

        td.text-small {
            font-size: calc(var(--font-size)*5/6);
        }

        td.not-av {
            background-image: radial-gradient(circle, rgb(203 213 225) 2px, #fff 2px);
        }

        span {
            width: var(--tile-width);
        }

        span.w-2 {
            --mf: 2;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + var(--margin) * var(--mf)) * var(--mf))
        }

        span.w-3 {
            --mf: 3;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * (var(--mf) - 1))) * var(--mf))
        }

        span.w-4 {
            --mf: 4;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * (var(--mf) - 1))) * var(--mf))
        }

        span.w-5 {
            --mf: 5;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * (var(--mf) - 1))) * var(--mf))
        }

        td.w-3 {
            --mf: 6;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * (var(--mf) + 1))) * var(--mf))
        }

        .drag-span {
            background-color: #e3f2fd;
            padding: var(--padding);
            margin: var(--margin);
            cursor: move;
            border: 1px solid #90caf9;
            border-radius: 4px;
            user-select: none;
            text-align: center;
            /* overflow: hidden; */
        }

        .warn-span {
            border-bottom: 3px solid #b80404;
        }

        .display-block {
            display: block;
        }

        .display-inline-block {
            display: inline-block;
        }

        .display-none {
            display: none;
        }

        .dragging {
            opacity: 0.8;
            border-style: dashed;
        }

        .highlight {
            background-color: #ddf314;
        }

        .spot-expelled {
            background-color: #fdc9c9;
        }

        .spot-last-cell {
            background-color: #eff7a7;
        }

        .no-drag {
            pointer-events: none;
        }

        td.warehouse {
            border: none;
            min-width: calc(var(--tile-width)*3);
            background-color: #fafafa;
        }

        td.warehouse>* {
            vertical-align: middle;
        }

        td.footer {
            border: none;
            padding-top: 5px;
            font-size: 10px;
            color: #6c6d6e;
            text-align: center;
            vertical-align: top;
            max-width: var(--tile-width);
            word-wrap: break-word;
            background-color: #fafafa;
        }

        div.whiteboard {
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: normal;
            font-size: 16px;
            background-color: #fafafa;
            padding: 5px;
            margin: var(--margin);
            border-radius: 4px;
            border: 1px solid;
            border-color: #eeeeee;
        }

        td.strike {
            text-decoration: line-through;
        }

        #tablediv {
            display: inline-block;
            margin: auto;
        }

        #undo-redo {
            position: fixed;
            top: 2px;
            left: 5px;
        }

        .undo-redo-button {
            margin: 0px 2px 0px 2px;
            padding: 0px 5px 0px 5px;
            background-color: #fafafa;
            border-radius: 4px;
            border: 1px solid;
            border-color: #eeeeee;
            cursor: pointer;
        }

        #tablecontainer {
            display: flex;
        }

        .gth {
            position: fixed;
            bottom: 1px;
            left: 50%;
            transform: translateX(-50%);
            color: rgb(155, 155, 155);
            text-align: center;
            text-decoration: none;
            font-size: 12px;
        }

        .a-gth {
            color: inherit;
            text-decoration: none;
        }

        @media print {
            .no-print {
                display: none;
            }

            .print-table {
                page-break-inside: avoid !important;
            }
        }

        /* The Modal (background) */
        .modal {
            display: none;
            /* Hidden by default */
            position: fixed;
            /* Stay in place */
            z-index: 1;
            /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
            overflow: auto;
            /* Enable scroll if needed */
            background-color: rgba(0, 0, 0, 0.4);
            /* Black w/ opacity */
        }

        /* Modal Content/Box */
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            /* Could be more or less, depending on screen size */
            max-width: 600px;
            border-radius: 5px;
        }

        /* Close Button */
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: normal;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* Modal Header */
        .modal-header {
            padding: 10px 0;
            border-bottom: 1px solid #ddd;
        }

        /* Modal Body */
        .modal-body {
            padding: 15px 0;
        }

        /* Error Modal Styles */
        .error-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .error-modal-content {
            background-color: #ffe6e6;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #ff4444;
            width: 80%;
            max-width: 500px;
            border-radius: 5px;
            position: relative;
        }

        .error-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            color: #cc0000;
        }

        .error-icon {
            font-size: 24px;
            margin-right: 10px;
        }

        .error-title {
            font-size: 20px;
            font-weight: normal;
        }

        .error-message {
            margin: 10px 0;
            color: #333;
        }

        .error-close-btn {
            background-color: #cc0000;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .error-close-btn:hover {
            background-color: #b30000;
        }

        .top-span {
            width: 100%;
            overflow: hidden;
        }

        .bottom-span {
            display: block;
            width: 100%;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="container" class="container">
        <h1>FET - edit + print</h1>
        <p>Please input a locked (data_and_timetable) fet file</p>
        <input type="file" id="xmlFileInput" accept=".fet">
    </div>

    <div id="undo-redo">
        <div id="refresh" onclick="window.location.reload()" class="undo-redo-button display-inline-block no-print"
            title="Reload">&#10227;</div>
        <div id="aboutBtn" class="undo-redo-button display-inline-block no-print" title="About">&quest;</div>
        <div id="rtl" onclick="changeDirection()" class="undo-redo-button display-none no-print show-hide"
            title="Change direction">&harr;</div>
        <div id="down" onclick="downloadXml()" class="undo-redo-button display-none no-print show-hide"
            title="Download fet file">&dArr;</div>
        <div id="toggleFooter" onclick="toggleFooterVisible()" class="undo-redo-button display-none no-print show-hide"
            title="Toggle footer visible">&oplus;</div>
        <div id="showSubject" class="undo-redo-button display-none no-print show-hide"
            title="Show/Hide subject&#10;Click left - right&#10;to set font size">&nbsp;&ctdot;&nbsp;
        </div>
        <div id="setTileWidth" onclick="setTileWidth()" class="undo-redo-button display-none no-print show-hide"
            title="Set width of cards">&harr;
        </div>
        <div id="setTitle" onclick="setTitle()" class="undo-redo-button display-none no-print show-hide"
            title="Set title">&#9997;</div>
        <div id="printTeachers" onclick="printTeachersSchedule()"
            class="undo-redo-button display-none no-print show-hide" title="Print Teachers Schedule">T</div>
        <div id="printGroups" onclick="printGroupsSchedule()" class="undo-redo-button display-none no-print show-hide"
            title="Print Groups Schedule">G</div>
        <div id="prev" onclick="prev()" class="undo-redo-button display-none no-print show-hide" title="Undo">&larr;
        </div>
        <div id="next" onclick="next()" class="undo-redo-button display-none no-print show-hide" title="Redo">&rarr;
        </div>
    </div>

    <div id="tablecontainer">
        <div id="tablediv">
            <h2 id='title'>&nbsp;</h2>

            <table id="programTable">
                <thead></thead>
                <tbody></tbody>
                <tfoot></tfoot>
            </table>
        </div>

        <div class="gth  no-print">
            <span>copyright: George Theodoroy, licence: MIT Licence, mail: </span>
            <a class="a-gth" href="mailto:g.theodoroy@gmail.com?subject=FET-edit+print"
                title="mail to: George Theodoroy">GΘ@2025</a>
        </div>

    </div>

    <div id="whiteboard" class="whiteboard display-none"></div>

    <!-- The Modal -->
    <div id="aboutModal" class="modal">
        <!-- Modal content -->
        <div class="modal-content">
            <div class="modal-header">
                <span class="close">&times;</span>
                <h2>About FET - edit + print</h2>
            </div>
            <div class="modal-body">
                <p>This "program" was created in February 2025 by:</p>
                <blockquote>
                    <p>George Theodoroy</p>
                </blockquote>
                <blockquote>
                    <p>email: g.theodoroy&commat;gmail.com</p>
                </blockquote>
                <p>It is provided as is under "MIT License": https://opensource.org/license/mit</p>

                <p>&nbsp;</p>

                <p>FET - edit + print is free. If you like you can treat me a coffee ...</p>

                <form action="https://www.paypal.com/donate" method="post" target="_blank" style="text-align: center">
                    <input type="hidden" name="hosted_button_id" value="C2VEYT3GPPNY4">
                    <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
                        name="submit" title="PayPal - The safer, easier way to pay online!"
                        alt="Donate with PayPal button">
                    <!-- <img alt="" border="0" src="https://www.paypal.com/en_GR/i/scr/pixel.gif" width="1" height="1" /> -->
                </form>

            </div>
        </div>
    </div>

    <div id="errorModal" class="error-modal">
        <div class="error-modal-content">
            <div class="error-header">
                <div class="error-icon">&#9888;</div>
                <div class="error-title" id="errorTitle"></div>
            </div>
            <div class="error-message" id="errorMessage"></div>
            <button class="error-close-btn" onclick="closeError()">OK</button>
        </div>
    </div>

    <script>

        const showColors = true
        const spotExpellDuration = 7000
        const excludeInactiveActivities = true

        // removes lightgreen background of row and green background of cells
        const removeBackground = (cell) => {
            draggedElement.parentElement.parentElement.parentElement.rows[draggedElement.getAttribute('row') - 2].style.background = ''
            Array.from(draggedElement.parentElement.parentElement.parentElement.rows[draggedElement.getAttribute('row') - 2].cells)
                .forEach(c => c.style.background = '')
        }

        // sets lightgreen background to teacher row 
        // sets green background to cells where student-class is missing
        const setBackgroundGreen = (cell) => {
            const table = document.getElementById('programTable')
            const theRow = draggedElement.getAttribute('row') - 2

            const dragElTmima = draggedElement.getAttribute('tmima')
            const dragElRoom = draggedElement.getAttribute('room')

            table.tBodies[0].rows[theRow].style.background = '#cfffd7'

            // find possible positions from missing groups stored in footer cell
            const possiblePositions = Array.from(table.tFoot.rows[0].cells).filter(c => c.innerText !== '')
            possiblePositions.forEach(p => {
                if (p.innerText.includes(dragElTmima)) {
                    // if cell marked not-availiable for teacher continue
                    if (table.tBodies[0].rows[theRow].cells[p.cellIndex].classList.contains('not-av')) { return }
                    // if room of dragged element is occupied by other group continue
                    if (dragElRoom && table.tFoot.rows[0].cells[p.cellIndex].getAttribute('rooms').split(',').includes(dragElRoom)) { return }
                    // all free (group and room). Mark green 
                    table.tBodies[0].rows[theRow].cells[p.cellIndex].style.background = 'green'
                }
            })
        }

        // global variables
        let loadedXml = null;
        let xmlName = null;
        let draggedElement = null;
        let warehouseColumnIndex = null;
        let hoursLength = null
        let groupsArray = []
        let xmlGroupsArray = []
        let subgroupsArray = []
        let noTeacher = false;
        let showFooter = false;
        let tileWidth = null;
        let initFontSize = '0.4rem';

        // NN -> NodeName
        let NN_DAY = 'Preferred_Day'
        let NN_HOUR = 'Preferred_Hour'

        // add event listener to file element
        document.getElementById('xmlFileInput').addEventListener('change', handleFileSelect, false);

        function handleFileSelect(event) {

            const file = event.target.files[0];
            if (!file) return;

            // set name of file for later use
            xmlName = file.name

            // read fet file
            const reader = new FileReader();

            reader.onload = function (e) {
                try {

                    const xmlContent = e.target.result;
                    const xmlDoc = new window.DOMParser().parseFromString(xmlContent, "text/xml")
                    // Check for parsing errors
                    const errorNodes = xmlDoc.getElementsByTagName("parsererror");
                    if (errorNodes.length > 0) {
                        throw new Error('Error parsing XML');
                    }

                    // Process the XML
                    displayXMLContent(xmlDoc);

                    // Store modified XML
                    const serializer = new XMLSerializer();
                    loadedXml = serializer.serializeToString(xmlDoc);

                } catch (error) {
                    console.log(`Error: ${error.message}`);
                    showError('Error', 'Error reading - loading data from "' + xmlName + '".')
                }
            };

            reader.onerror = function () {
                console.log('Error reading file');
                showError('Error', 'Error reading - loading data from "' + xmlName + '".')
            };

            reader.readAsText(file);

            // save filename for later use
            xmlName = file.name

            // set UI - set title - show-hide buttons first-screen
            document.getElementById('xmlFileInput').value = '';
            document.getElementById('container').style.display = 'none';
            document.getElementById('title').textContent = file.name;
            // loop through buttons with class 'show-hide' and set them visible
            const showHide = Array.from(document.querySelectorAll(`.show-hide`))
            showHide.forEach(el => {
                el.classList.remove('display-none')
                el.classList.add('display-inline-block')
            })
        }

        // Download modified XML
        function downloadXml() {
            if (!loadedXml) {
                alert('Please load an XML file first!');
                return;
            }

            // load xml to DOM
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(loadedXml, "application/xml");

            // get all ConstraintActivityPreferredStartingTime
            const ConstraintActivityPreferredStartingTime = xmlDoc.evaluate('//fet/Time_Constraints_List/ConstraintActivityPreferredStartingTime', xmlDoc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);

            // get all cards
            let allSpans = Array.from(document.querySelectorAll(`.drag-span`))

            for (i = 0; i < ConstraintActivityPreferredStartingTime.snapshotLength; i++) {
                xmlElement = ConstraintActivityPreferredStartingTime.snapshotItem(i)
                // get Activity_Id and find spans with the same id
                const id = xmlElement.getElementsByTagName('Activity_Id')[0].textContent
                const span = allSpans.filter(sp => sp.id == id)

                // cards with same id might be 1 or 2 ( 2 when are 2 teacher at a class)
                // remove items to finally track if all of them are processed 
                for (j = 0; j < span.length; j++) {
                    allSpans.splice(allSpans.indexOf(span[j]), 1)
                }

                // in case of Activities with Active = false that we don't load
                // might be ConstraintActivityPreferredStartingTime but no card
                // so if no span[0] bypass
                if (!span[0]) continue

                // every cell (span.parenElement) has attributes of Day and Hour
                // warehouse cells have not
                // if cell has Day and Hour card is in program. Set values to xml
                if (span[0].parentElement.getAttribute('day')) {
                    xmlElement.getElementsByTagName(NN_DAY)[0].textContent = span[0].parentElement.getAttribute('day')
                    xmlElement.getElementsByTagName(NN_HOUR)[0].textContent = span[0].parentElement.getAttribute('hour')
                } else {
                    // if no Day (warehouse) remove node element from xml
                    xmlElement.parentElement.removeChild(xmlElement);
                }
            }

            // if allSpans contains entries must append them to xml

            // filter to exclude cards in warehouse
            allSpans = allSpans.filter(sp => !(sp.getAttribute('col') == warehouseColumnIndex))

            //remove the remaining double card of cards with same id (2 teachers in 1 class)
            let toRemove = []
            for (i in allSpans) {
                // find cards with same id 
                sameIdSpans = allSpans.filter(sp => sp.id == allSpans[i].id)
                if (sameIdSpans.length > 1) {
                    // if they are more than one it means that two teachers are in the same class
                    // i save as key => value card.id => index to remove
                    toRemove[allSpans.findIndex(item => item.id === sameIdSpans[1].id)] = i
                }
            }
            //  sort descending to avoid array index undefined
            var keys = Object.keys(toRemove).sort(function (a, b) { return b - a; });
            for (var i = 0; i < keys.length; i++) {
                allSpans.splice(toRemove[keys[i]], 1);
            }

            // append remaining allSpans entries to xml

            // <ConstraintActivityPreferredStartingTime>
            // 	 <Weight_Percentage>100</Weight_Percentage>
            // 	 <Activity_Id>134</Activity_Id>
            // 	 <Preferred_Day>Πε</Preferred_Day>  - after version 7.1.4 <Day>Πε</Day>
            // 	 <Preferred_Hour>2</Preferred_Hour> - after version 7.1.4 <Hour>Πε</Hour>
            // 	 <Permanently_Locked>false</Permanently_Locked>
            // 	 <Active>true</Active>
            // 	 <Comments></Comments>
            // </ConstraintActivityPreferredStartingTime>

            const TimeConstraintsList = xmlDoc.getElementsByTagName('Time_Constraints_List')

            for (i = 0; i < allSpans.length; i++) {
                const newElem = xmlDoc.createElement("ConstraintActivityPreferredStartingTime");

                let newElemChild = xmlDoc.createElement("Weight_Percentage");
                let newText = xmlDoc.createTextNode(100);
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement("Activity_Id");
                newText = xmlDoc.createTextNode(allSpans[i].id);
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement(NN_DAY);
                newText = xmlDoc.createTextNode(allSpans[i].parentElement.getAttribute('day'));
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement(NN_HOUR);
                newText = xmlDoc.createTextNode(allSpans[i].parentElement.getAttribute('hour'));
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement("Permanently_Locked");
                newText = xmlDoc.createTextNode('false');
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement("Active");
                newText = xmlDoc.createTextNode('true');
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement("Comments");
                newElem.appendChild(newElemChild)

                TimeConstraintsList[0].appendChild(newElem)

            }

            // ask user to confirm if he/she wants to set all time constraints to inactive
            var ok = confirm('Disable all unnecessary constrains?\nPlease confirm.')
            if (ok) {

                // Time_Constraints_List
                // set all Time_Constraints_List to inactive
                // except - ConstraintBasicCompulsoryTime - ConstraintActivityPreferredStartingTime
                const xmlTimeElements = xmlDoc.evaluate('//fet/Time_Constraints_List', xmlDoc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                for (i = 0; i < xmlTimeElements.snapshotItem(0).children.length; i++) {
                    if (xmlTimeElements.snapshotItem(0).children[i].localName == 'ConstraintBasicCompulsoryTime') { continue }
                    if (xmlTimeElements.snapshotItem(0).children[i].localName == 'ConstraintActivityPreferredStartingTime') { continue }
                    xmlTimeElements.snapshotItem(0).children[i].getElementsByTagName('Active')[0].textContent = 'false'
                }

                // Space_Constraints_List
                // set all Space_Constraints_List to inactive
                // except - ConstraintBasicCompulsorySpace
                const xmlSpaceElements = xmlDoc.evaluate('//fet/Space_Constraints_List', xmlDoc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                for (i = 0; i < xmlSpaceElements.snapshotItem(0).children.length; i++) {
                    if (xmlSpaceElements.snapshotItem(0).children[i].localName == 'ConstraintBasicCompulsorySpace') { continue }
                    xmlSpaceElements.snapshotItem(0).children[i].getElementsByTagName('Active')[0].textContent = 'false'
                }
            }

            // pretty format modified XML
            const serializer = new XMLSerializer();
            XmlDownload = prettyFormatXml(serializer.serializeToString(xmlDoc))
            XmlDownload = '\ufeff' + XmlDownload + '\n';

            // send it for download
            const blob = new Blob([XmlDownload], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;

            // add _edit_print to filename
            const ext = xmlName.slice(xmlName.lastIndexOf("."))
            const name = xmlName.slice(0, xmlName.lastIndexOf(".")) + '_edit_print'

            a.download = name + ext;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // format xml (it is not elegant but does the job)
        /* the desired result
          <ConstraintActivityPreferredStartingTime>
            <Weight_Percentage>100</Weight_Percentage>
            <Activity_Id>134</Activity_Id>
            <Preferred_Day>Πε</Preferred_Day>  - after version 7.1.4 <Day>Πε</Day>
            <Preferred_Hour>2</Preferred_Hour> - after version 7.1.4 <Hour>Πε</Hour>
            <Permanently_Locked>false</Permanently_Locked>
            <Active>true</Active>
            <Comments/>
          </ConstraintActivityPreferredStartingTime>
        */
        function prettyFormatXml(xml) {
            xml = xml.replace(/\n{2,}/g, '\n');
            xml = xml.replace(/(<ConstraintActivityPreferredStartingTime>)(<)/g, '  $1\n      $2')
            xml = xml.replace(/(<\/Weight_Percentage>)(<)/g, '$1\n      $2')
            xml = xml.replace(/(<\/Activity_Id>)(<)/g, '$1\n      $2')
            let re = new RegExp(String.raw`(<\/${NN_DAY}>)(<)`, "g");
            xml = xml.replace(re, '$1\n      $2')
            re = new RegExp(String.raw`(<\/${NN_HOUR}>)(<)`, "g");
            xml = xml.replace(re, '$1\n      $2')
            xml = xml.replace(/(<\/Permanently_Locked>)(<)/g, '$1\n      $2')
            xml = xml.replace(/(<\/Active>)(<)/g, '$1\n      $2')
            xml = xml.replace(/(<Comments\/>)(<)/g, '$1\n    $2')
            xml = xml.replace(/(<\/ConstraintActivityPreferredStartingTime>)(\s*<)/g, '$1\n  $2')
            return xml
        }

        function displayXMLContent(xml) {

            // get version of fet. If version is greater from 7.1.3 change NodeName NN_DAY & NN_HOUR
            const version = parseFloat(xml.getElementsByTagName("fet")[0].getAttribute('version').replace(/(?<=\..*)\./g, ''))
            if (version > 7.13) {
                NN_DAY = 'Day'
                NN_HOUR = 'Hour'
            }

            // read data from xml
            const NumOfDays = xml.getElementsByTagName("Number_of_Days")[0].textContent;
            const NumOfHours = xml.getElementsByTagName("Number_of_Hours")[0].textContent;
            const tableColNum = NumOfDays * NumOfHours + 1

            // read days
            const daysList = xml.getElementsByTagName("Days_List");
            const days = daysList[0].getElementsByTagName("Day");
            // make array of [dayName] = index
            const daysIndexList = {}
            for (let i = 0; i < days.length; i++) {
                daysIndexList[days[i].getElementsByTagName("Name")[0].textContent] = i
            }

            // read hours
            const hoursList = xml.getElementsByTagName("Hours_List");
            const hours = hoursList[0].getElementsByTagName("Hour");
            hoursLength = hours.length
            // make array of [hourName] = index
            const hoursIndexList = {}
            for (let i = 0; i < hoursLength; i++) {
                hoursIndexList[hours[i].getElementsByTagName("Name")[0].textContent] = i
            }

            // read teachers
            const teachersList = xml.getElementsByTagName("Teachers_List");
            const teachers = teachersList[0].getElementsByTagName("Teacher");
            // arrays of teacherData - teacherColor
            const teachersIndexList = {}
            const teachersColor = {}
            for (let i = 0; i < teachers.length; i++) {
                let randomColor = Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                while (!isLightColor(randomColor)) {
                    randomColor = Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                }
                const teacherName = teachers[i].getElementsByTagName("Name")[0].textContent
                teachersIndexList[teacherName] = i + 2
                teachersColor[teacherName] = '#' + randomColor
            }
            const tableRowNum = Object.keys(teachersIndexList).length + 2

            // read teachers not available times
            const teachersNotAvailable = xml.getElementsByTagName("ConstraintTeacherNotAvailableTimes");
            const teachNotAvailable = [];
            for (let i = 0; i < teachersNotAvailable.length; i++) {
                const teacherNA = teachersNotAvailable[i].getElementsByTagName("Teacher")[0].textContent
                const countNA = teachersNotAvailable[i].getElementsByTagName("Number_of_Not_Available_Times")[0].textContent
                const timesNA = teachersNotAvailable[i].getElementsByTagName("Not_Available_Time")
                rowNA = teachersIndexList[teacherNA]

                for (let j = 0; j < timesNA.length; j++) {
                    d = timesNA[j].getElementsByTagName("Day")[0].textContent
                    h = timesNA[j].getElementsByTagName("Hour")[0].textContent
                    colNA = daysIndexList[d] * NumOfHours + hoursIndexList[h] + 1
                    teachNotAvailable.push({ 'r': rowNA, 'c': colNA })
                }
            }


            // read Croups from fet file
            // create array of Subgroups for each Group
            const xmlGroups = xml.getElementsByTagName("Group");
            for (let i = 0; i < xmlGroups.length; i++) {
                const subgroup = xmlGroups[i].getElementsByTagName("Subgroup")
                const dummyArr = []
                for (let y = 0; y < subgroup.length; y++) {
                    dummyArr.push(subgroup[y].getElementsByTagName("Name")[0].textContent)
                }
                if (dummyArr.length) {
                    xmlGroupsArray[xmlGroups[i].getElementsByTagName("Name")[0].textContent] = dummyArr
                }
            }


            // read Subroups
            // create array of each Subgroup with its parent Group
            const subgroups = xml.getElementsByTagName("Subgroup");
            for (let i = 0; i < subgroups.length; i++) {
                subgroupsArray[subgroups[i].getElementsByTagName("Name")[0].textContent] = [
                    subgroups[i].getElementsByTagName("Name")[0].textContent,
                    subgroups[i].parentElement.getElementsByTagName("Name")[0].textContent
                ]
            }


            // read activities
            // read STUDENTS from ACTIVITIES so i don't care if students come FROM YEAR or GROUP or SUBGROUP
            const activities = xml.getElementsByTagName("Activity");
            const objAct = {}

            for (let i = 0; i < activities.length; i++) {

                // const excludeInactiveActivities is set in line 495
                // if true we dont import inactive activities
                if (excludeInactiveActivities) {
                    // if activity Active = false bypass
                    if (activities[i].getElementsByTagName("Active")[0].textContent !== 'true') continue
                }

                // teachers might be one or two so i make an array of them
                const teachers = activities[i].getElementsByTagName("Teacher")
                let teacherArray = []
                for (let j = 0; j < teachers.length; j++) {
                    teacherArray.push(teachers[j].textContent)
                }
                let teacherStr = teacherArray.join(' - ')

                const subject = activities[i].getElementsByTagName("Subject")[0].textContent
                const tmimata = activities[i].getElementsByTagName("Students")
                // groups might be one or two so so i make an array of them
                const tmimaArray = []
                for (let j = 0; j < tmimata.length; j++) {
                    tmimaArray.push(tmimata[j].textContent)
                }
                const tmima = tmimaArray.join(' ')

                // read groups of Students in activities and create array of them
                groupsArray = groupsArray.concat(tmimaArray)

                const duration = activities[i].getElementsByTagName("Duration")[0].textContent
                const totalDuration = activities[i].getElementsByTagName("Total_Duration")[0].textContent
                const id = activities[i].getElementsByTagName("Id")[0].textContent

                objAct[id] = {
                    'duration': duration,
                    'totalDuration': totalDuration,
                    'tmimata': tmimaArray,
                    'tmima': tmima,
                    'teacher': teacherArray,
                    'teacherStr': teacherStr,
                    'subject': subject
                }

                if (!teachers.length) noTeacher = true
            }

            if (noTeacher) {
                teachersIndexList['notAv'] = Object.keys(teachersIndexList).length + 2
            }

            // keep values of groupsArray only once ( unique)
            let uniqueArrGroups = []
            groupsArray.forEach(el => {
                if (!uniqueArrGroups.includes(el)) {
                    uniqueArrGroups.push(el)
                }
            })
            // final groupsArray = sorted uniqueArrGroups
            groupsArray = uniqueArrGroups.sort()

            // read activities start times
            const activitiesStartTimes = xml.getElementsByTagName("ConstraintActivityPreferredStartingTime");
            const objActivitiesStartTimes = []

            for (let i = 0; i < activitiesStartTimes.length; i++) {

                // load only "Active = true" ConstraintActivityPreferredStartingTime
                if (activitiesStartTimes[i].getElementsByTagName("Active")[0].textContent == "false") continue

                const id = activitiesStartTimes[i].getElementsByTagName("Activity_Id")[0].textContent

                // if activity Active = false is bypassed and there is no id
                // so we don,t add the card
                if (!objAct[id]) continue

                const d = activitiesStartTimes[i].getElementsByTagName(NN_DAY)[0].textContent
                const h = activitiesStartTimes[i].getElementsByTagName(NN_HOUR)[0].textContent
                const teacherArr = objAct[id].teacher
                // if teacher present
                if (teacherArr.length) {
                    // set row, col, data for every teacher 
                    for (j = 0; j < teacherArr.length; j++) {
                        const rowSet = teachersIndexList[teacherArr[j]]
                        const colSet = daysIndexList[d] * NumOfHours + hoursIndexList[h] + 1
                        objActivitiesStartTimes.push({
                            'id': id,
                            'r': rowSet,
                            'c': colSet,
                            'data': objAct[id],
                            'color': teachersColor[teacherArr[j]]
                        })
                    }

                } else {
                    // no teacher
                    const rowSet = teachersIndexList['notAv']
                    const colSet = daysIndexList[d] * NumOfHours + hoursIndexList[h] + 1
                    objActivitiesStartTimes.push({
                        'id': id,
                        'r': rowSet,
                        'c': colSet,
                        'data': objAct[id] //? objAct[id] : {}
                    })

                }
            }


            // read activities rooms and add them in objAct

            const activitiesRooms = xml.getElementsByTagName("ConstraintActivityPreferredRoom");

            for (let i = 0; i < activitiesRooms.length; i++) {

                // load only "Active = true" ConstraintActivityPreferredStartingTime
                if (activitiesRooms[i].getElementsByTagName("Active")[0].textContent == "false") continue

                const id = activitiesRooms[i].getElementsByTagName("Activity_Id")[0].textContent

                // if activity Active = false is bypassed and there is no id
                // so we don,t add the card
                if (!objAct[id]) continue

                objAct[id].room = activitiesRooms[i].getElementsByTagName("Room")[0].textContent
            }

            // -------- create table ------------
            const table = document.getElementById("programTable");
            const thead = table.tHead
            const tbody = table.tBodies[0]
            const tfoot = table.tFoot

            let row = tfoot.insertRow()
            for (i = 0; i < tableColNum; i++) {
                let cell = row.insertCell()
                cell.setAttribute('col', i)
                cell.classList.add('footer', 'no-print', 'display-none')
            }


            // 1st row ------
            row = thead.insertRow();
            // title of table
            cell = row.insertCell()
            cell.rowSpan = 2
            cell.textContent = "FET - edit + print";
            cell.classList.add('mark-border')
            cell.style.background = '#f5fbff'
            cell.style.textAlign = 'center'
            cell.style.fontSize = '20px'
            cell.style.color = '#11496e'
            // date names
            for (let i = 0; i < days.length; i++) {
                const dayShort = days[i].getElementsByTagName("Name")[0].textContent;
                const dayLong = days[i].getElementsByTagName("Long_Name")[0].textContent;
                const dateName = dayLong ? dayLong : dayShort;
                let cell = row.insertCell()
                cell.colSpan = NumOfHours
                cell.textContent = dateName
                cell.classList.add('text-center', 'day')
                cell.classList.add('mark-border')
                cell.style.cursor = 'pointer'
                cell.title = 'Do not print'
                cell.setAttribute('index', i + 1)
            }

            // 2nd row -----
            row = thead.insertRow();

            // hour names
            for (let i = 0; i < days.length; i++) {
                for (let j = 0; j < hours.length; j++) {
                    const hourShort = hours[j].getElementsByTagName("Name")[0].textContent;
                    const hourLong = hours[j].getElementsByTagName("Long_Name")[0].textContent;
                    const glue = hourShort && hourLong ? '\n ' : '';
                    const hourName = hourShort + glue + hourLong
                    cell = row.insertCell()
                    cell.textContent = hours[j].getElementsByTagName("Name")[0].textContent
                    cell.title = hourName
                    cell.classList.add('text-center', 'hour')

                    if (j == hours.length - 1) {
                        cell.classList.add('mark-border')
                    }
                }
            }

            // 3rd row and after -----
            // enter schedule data

            for (let i = 0; i < Object.keys(teachersIndexList).length; i++) {
                let row = tbody.insertRow();
                // 1st column - teacher names
                cell = row.insertCell()
                cell.textContent = Object.keys(teachersIndexList)[i] == 'notAv' ? '' : Object.keys(teachersIndexList)[i]
                cell.classList.add('text-small')
                cell.classList.add('mark-border')
                cell.classList.add('teacher-name')
                cell.title = "Do not print"
                cell.style.cursor = 'pointer'
                // cells of schedule
                for (let j = 0; j < days.length; j++) {
                    for (let k = 0; k < hours.length; k++) {
                        cell = row.insertCell()
                        cell.classList.add('program')
                        if (k == hours.length - 1) {
                            cell.classList.add('mark-border')
                        }
                        // set to every cell values of day and hour to be accesible later
                        cell.setAttribute('day', days[j].getElementsByTagName("Name")[0].textContent)
                        cell.setAttribute('hour', hours[k].getElementsByTagName("Name")[0].textContent)
                    }
                }
                // warehouse
                cell = row.insertCell()
                cell.classList.add('warehouse')
                cell.classList.add('no-print')
                warehouseColumnIndex = cell.cellIndex

            }

            // mark not available hours of teacher
            for (let i = 0; i < teachNotAvailable.length; i++) {
                cell = table.rows[teachNotAvailable[i].r].cells[teachNotAvailable[i].c]
                cell.classList.add("not-av")

            }

            // insert activities
            for (let i = 0; i < objActivitiesStartTimes.length; i++) {
                // get cell
                row = table.rows[objActivitiesStartTimes[i].r]
                cell = row.cells[objActivitiesStartTimes[i].c]

                // delete from activities if is set objActivitiesStartTimes
                delete objAct[objActivitiesStartTimes[i].id]

                // create the cards (spans)
                const tmimaSpan = document.createElement("span");
                tmimaSpan.setAttribute("class", "drag-span display-inline-block");
                tmimaSpan.id = objActivitiesStartTimes[i].id;
                tmimaSpan.setAttribute("teacher", objActivitiesStartTimes[i].data.teacherStr);
                tmimaSpan.setAttribute("tmima", objActivitiesStartTimes[i].data.tmimata);
                objActivitiesStartTimes[i].data.room ? tmimaSpan.setAttribute("room", objActivitiesStartTimes[i].data.room) : false
                tmimaSpan.setAttribute("row", row.rowIndex);
                tmimaSpan.setAttribute("col", cell.cellIndex);
                tmimaSpan.innerHTML = `<span class="top-span display-none" style="font-size:${initFontSize}">` + objActivitiesStartTimes[i].data.subject + '</span>' + '<span class="bottom-span">' + objActivitiesStartTimes[i].data.tmima + '</span>' + `<span class="top-span display-none" style="font-size:${initFontSize}">` + (objActivitiesStartTimes[i].data.room ? "\n" + objActivitiesStartTimes[i].data.room : '');
                tmimaSpan.setAttribute('info', objActivitiesStartTimes[i].data.tmima + " - " + objActivitiesStartTimes[i].data.duration + '/' + objActivitiesStartTimes[i].data.totalDuration + "\n" + objActivitiesStartTimes[i].data.subject + "\n" + objActivitiesStartTimes[i].data.teacherStr + (objActivitiesStartTimes[i].data.room ? "\n" + objActivitiesStartTimes[i].data.room : ''))
                tmimaSpan.draggable = true;
                if (showColors) tmimaSpan.style.background = objActivitiesStartTimes[i].color
                // add card to cell
                cell.appendChild(tmimaSpan)
                // set data to cell
                cell.id = objActivitiesStartTimes[i].id
                cell.setAttribute('tmima', objActivitiesStartTimes[i].data.tmimata)
                objActivitiesStartTimes[i].data.room ? cell.setAttribute("room", objActivitiesStartTimes[i].data.room) : false

                // make cards wide to simulate duration
                // all cards have duration 1
                tmimaSpan.setAttribute("w", 1);
                // if duration > 1 set width
                clspn = objActivitiesStartTimes[i].data.duration
                if (clspn > 1) {
                    tmimaSpan.classList.add("w-" + clspn)
                    tmimaSpan.setAttribute("w", clspn);
                    index = cell.cellIndex
                    for (j = 0; j < clspn; j++) {
                        // set group to all cells that occupies the card
                        row.cells[index + j].id = objActivitiesStartTimes[i].id
                        // set start - stop indexes for loop through cells
                        // a triple wide card occupies three cells
                        // cell 1  => start = 0,  stop = 2
                        // cell 2  => start = -1, stop = 1
                        // cell 3 => start = -2,  stop = 0
                        // that way i know in which cell the card belongs
                        row.cells[index + j].setAttribute('tmima', objActivitiesStartTimes[i].data.tmimata)
                        if (objActivitiesStartTimes[i].data.room) row.cells[index + j].setAttribute('room', objActivitiesStartTimes[i].data.room)
                        row.cells[index + j].setAttribute('start', 0 - j)
                        row.cells[index + j].setAttribute('stop', clspn - 1 - j)
                    }

                }
            }

            // if Activities left in objAct means that 
            // these activities have no preferedStartingTime
            // so they must be put to warehouse
            for (let index of Object.keys(objAct)) {
                for (i = 0; i < objAct[index].teacher.length; i++) {
                    // create the cards (spans)
                    var tmimaSpan = document.createElement("span");
                    tmimaSpan.setAttribute("class", "drag-span display-inline-block");
                    tmimaSpan.id = index;
                    tmimaSpan.setAttribute("teacher", objAct[index].teacherStr);
                    tmimaSpan.setAttribute("tmima", objAct[index].tmimata);
                    objAct[index].room ? tmimaSpan.setAttribute("room", objAct[index].room) : false
                    tmimaSpan.setAttribute("row", teachersIndexList[objAct[index].teacher[i]]);
                    tmimaSpan.setAttribute("col", warehouseColumnIndex);
                    tmimaSpan.innerHTML = `<span class="top-span display-none" style="font-size:${initFontSize}">` + objAct[index].subject + '</span>' + '<span class="bottom-span">' + objAct[index].tmima + '</span>' + `<span class="top-span display-none" style="font-size:${initFontSize}">` + (objAct[index].room ? "\n" + objAct[index].room : '');
                    tmimaSpan.setAttribute('info', objAct[index].tmima + " - " + objAct[index].duration + '/' + objAct[index].totalDuration + "\n" + objAct[index].subject + "\n" + objAct[index].teacherStr + (objAct[index].room ? "\n" + objAct[index].room : ''))
                    tmimaSpan.draggable = true;
                    if (showColors) tmimaSpan.style.background = teachersColor[objAct[index].teacher[i]]

                    tmimaSpan.setAttribute("w", 1);
                    // if duration > 1 set width
                    clspn = objAct[index].duration
                    if (clspn > 1) {
                        tmimaSpan.classList.add("w-" + clspn)
                        tmimaSpan.setAttribute("w", clspn);
                    }
                    // add card to cell
                    table.rows[tmimaSpan.getAttribute('row')].cells[warehouseColumnIndex].appendChild(tmimaSpan)

                }

            }

            eventListeners()
            saveTable(table)
        }

        // add eventListeners
        // should appended every time reconstruct table from history
        function eventListeners() {
            const table = document.getElementById('programTable')
            table.addEventListener('dragover', handleDragOver);
            table.addEventListener('drop', handleDrop);

            const spans = Array.from(document.querySelectorAll(`span`))
            spans.forEach(sp => {
                sp.addEventListener('dragstart', handleDragStart);
                sp.addEventListener('dragend', handleDragEnd);
                sp.ondblclick = () => handleDoubleClick(sp.id)
                sp.onmouseover = function () {
                    document.getElementById('whiteboard').innerText = this.getAttribute('info') ? this.getAttribute('info').replace(', ', '\n') : '';
                    document.getElementById('whiteboard').classList.remove('display-none');
                };
                sp.onmouseout = function () {
                    document.getElementById('whiteboard').innerText = '';
                    document.getElementById('whiteboard').classList.add('display-none');
                };
            })

            const teacherNameCells = Array.from(document.querySelectorAll(`.teacher-name`))
            teacherNameCells.forEach(c => {
                c.addEventListener('click', () => teacherNoPrint(c))
            })

            const dayRowCells = Array.from(document.querySelectorAll(`.day`))
            dayRowCells.forEach(d => {
                d.addEventListener('click', () => dayNoPrint(d.getAttribute('index')))
            })

            const hourColCells = Array.from(document.querySelectorAll(`.hour`))
            hourColCells.forEach(c => {
                c.onmouseover = function () {
                    document.getElementById('whiteboard').innerText = this.getAttribute('info') ? this.getAttribute('info').replace(', ', '\n') : '';
                    document.getElementById('whiteboard').classList.remove('display-none');
                };
                c.onmouseout = function () {
                    document.getElementById('whiteboard').innerText = '';
                    document.getElementById('whiteboard').classList.add('display-none');
                };
            })

            // clear backgrounds might be present ( and saved) when table was saved
            const spotLastCell = Array.from(document.querySelectorAll('.spot-last-cell'))
            spotLastCell.forEach(c => c.classList.remove('spot-last-cell'))

            const spotExpelled = Array.from(document.querySelectorAll('.spot-expelled'))
            spotExpelled.forEach(c => c.classList.remove('spot-expelled'))

            const highlighted = Array.from(document.querySelectorAll('.highlight'))
            highlighted.forEach(c => c.classList.remove('highlight'))

            markBorder()
            findMissingTmimata()
        }

        // saves table to sessionStorage
        function saveTable(table) {

            // set variables to session to track indexes
            const keepTables = sessionStorage.getItem("keep-tables")
            let first = sessionStorage.getItem("first-table-index")
            const last = sessionStorage.getItem("last-table-index")
            const current = sessionStorage.getItem("current-table-index")

            // if isset keepTables and the number of entries > keepTables remove items from beggining of stack
            if (keepTables) {
                if (last - first > keepTables) {
                    sessionStorage.removeItem('table#' + first)
                    first++
                    sessionStorage.setItem('first-table-index', first)
                }
            } else {
                sessionStorage.setItem('first-table-index', 0)
            }

            // calculate newIndex
            let newIndex = 0
            if (current) {
                newIndex = +current + +1
            }

            // save table
            // if memory is full it will throw error
            try {
                const tableJson = serializeDOM(table)
                sessionStorage.setItem('table#' + newIndex, JSON.stringify(tableJson))
                // set index after table saved
                // if memory full program throws exception in previous line so the indexes won't change
                sessionStorage.setItem('current-table-index', newIndex)
                sessionStorage.setItem('last-table-index', newIndex)
            } catch {
                // memory full
                // set keepTables to safe num newIndex - 2
                sessionStorage.setItem('keep-tables', newIndex - 2)
            }

            // if we are back in history and make new moves of cards
            // we delete all history after last current history
            if (newIndex !== last) {
                for (i = last; i > newIndex; i--) {
                    sessionStorage.removeItem('table#' + i)
                }
            }
            showHidePrevNext()
        }

        //  Determine if a color is a light color
        //  @see https://gist.github.com/krabs-github/ec56e4f1c12cddf86ae9c551aa9d9e04
        function isLightColor(color) {
            let r, g, b;

            // Check the format of the color, HEX or RGB?
            if (color.match(/^rgb/)) {
                // If HEX --> store the red, green, blue values in separate variables
                const rgb = color.match(
                    /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/
                );

                r = rgb[1];
                g = rgb[2];
                b = rgb[3];
            } else {
                // If RGB --> Convert it to HEX: http://gist.github.com/983661
                const hexColor = +(
                    '0x' + color.slice(1).replace(color.length < 5 && /./g, '$&$&')
                );

                r = hexColor >> 16;
                g = (hexColor >> 8) & 255;
                b = hexColor & 255;
            }

            // HSP equation from http://alienryderflex.com/hsp.html
            const hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));

            // Using the HSP value, determine whether the color is light or dark
            // > 127.5 is 'light', <= 127.5 is 'dark'

            //return hsp > 127.5;
            return hsp > 150;
        }

        function handleDragStart(e) {
            draggedElement = e.target;
            draggedElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            // set background green at allowed for drop row
            setBackgroundGreen(draggedElement)
            // change drag status of cards so i can target in background cells
            const spans = Array.from(document.querySelectorAll(`span`))
            spans.forEach(el => {
                if (el.id !== draggedElement.id) el.classList.add('no-drag')
            })
        }

        function handleDragEnd(e) {
            draggedElement.classList.remove('dragging');
            // set card drag status to default
            const spans = Array.from(document.querySelectorAll(`span`))
            spans.forEach(el => el.classList.remove('no-drag'))
        }

        function handleDragOver(e) {
            e.preventDefault();
            // highlight closer cell for drop
            const cell = e.target.closest('td');
            cell.classList.add('highlight');
            setTimeout(() => cell.classList.remove('highlight'), 200);
        }

        // clean things after drop
        function clearElement(el) {
            el.classList.remove('dragging');
            el = null;
        }

        function handleDrop(e) {
            e.preventDefault();

            const cell = e.target.closest('td');
            if (!(cell && draggedElement)) { return }

            const table = cell.parentElement.parentElement.parentElement

            const columnIndex = cell.cellIndex
            const tbody = cell.parentElement.parentElement
            const rowsLegth = tbody.rows.length

            let dropHour = cell.getAttribute('hour')?.replace(/[^0-9]/g, "")
            let dragHour = draggedElement.parentElement.getAttribute('hour')?.replace(/[^0-9]/g, "")
            if (draggedElement.getAttribute('w') > 1) {
                if (dragHour) {
                    dragStopHour = +dragHour + +draggedElement.getAttribute('w') - 1
                    dragHour = getOrdinal(dragHour) + ' - ' + getOrdinal(dragStopHour)
                }
                dropStopHour = +dropHour + +draggedElement.getAttribute('w') - 1
                dropHour = getOrdinal(dropHour) + ' - ' + getOrdinal(dropStopHour)
            } else {
                if (dragHour) dragHour = getOrdinal(dragHour)
                dropHour = getOrdinal(dropHour)
            }


            const dragElId = draggedElement.id
            const dragElTmima = draggedElement.getAttribute('tmima').split(',')
            const dragElRoom = draggedElement.getAttribute('room')
            const dragElRow = draggedElement.getAttribute('row')
            const dragElCol = draggedElement.getAttribute('col')
            const dragElSize = draggedElement.getAttribute('w')
            const dragElTeacher = draggedElement.getAttribute('teacher')

            // add subgroups or parent group to affected groups
            let affectedElTmimata = [...dragElTmima]
            if (xmlGroupsArray[dragElTmima] !== undefined) affectedElTmimata = [...affectedElTmimata, ...xmlGroupsArray[dragElTmima]]
            if (subgroupsArray[dragElTmima] !== undefined) affectedElTmimata = [...affectedElTmimata, ...subgroupsArray[dragElTmima]]

            // keep values of affectedElTmimata only once ( unique)
            affectedElTmimata = Array.from(new Set(affectedElTmimata))

            // set card drag status to default
            const spans = Array.from(document.querySelectorAll(`span`))
            spans.forEach(el => el.classList.remove('no-drag'))
            // all cells occupied of card have the same id
            // only the first holds the card id + start(=0) 
            const cellId = +cell.id + +cell.getAttribute('start')

            // if drop is in the old cell that drag started i do nothing
            if (dragElId == cellId) {
                removeBackground(draggedElement)
                clearElement(draggedElement)
                return
            }

            // if card size is 2 or 3 i prevent droping in last hours
            let lastHoursAllowance = columnIndex % hoursLength
            if (lastHoursAllowance == 0) {
                lastHoursAllowance = 1
            } else {
                lastHoursAllowance = hoursLength - lastHoursAllowance + 1
            }
            if (dragElSize > lastHoursAllowance) {
                removeBackground(draggedElement)
                clearElement(draggedElement)
                return
            }


            // 1st round
            // creating message for user checking what should do at 2nd round

            let message = []

            // get all cards with the same id as an array and loop
            const newDraggedElements1 = Array.from(document.querySelectorAll(`span[id="${draggedElement.id}"]`))
            newDraggedElements1.forEach(el => {
                let elRow = el.getAttribute('row')
                const newCell = table.rows[elRow].cells[columnIndex]
                // if drop cell has id, that means that a card is placed in it
                if (newCell.id) {
                    const existingElements = Array.from(document.querySelectorAll(`span[id="${newCell.id}"]`))
                    existingElements.forEach(el => {
                        const apo = +el.parentElement.getAttribute('hour').replace(/[^0-9]/g, "") + +el.parentElement.getAttribute('start')
                        const eos = +el.parentElement.getAttribute('hour').replace(/[^0-9]/g, "") + +el.parentElement.getAttribute('stop')
                        const oraStr = apo ? apo == eos ? getOrdinal(apo) + ' hour' : getOrdinal(apo) + ' to ' + getOrdinal(eos) + ' hours' : '';
                        message.push('\n' + (oraStr ? oraStr + '\n' : '') + el.parentElement.parentElement.cells[0].textContent + '\ngroup:    ' + el.getAttribute('tmima') + (el.getAttribute('room') ? '\nroom:     ' + el.getAttribute('room') : '') + '\n')
                    })
                }

                // if card size is 2 or 3 i check also the next cells if they have cards
                for (i = 0; i < dragElSize; i++) {
                    if (columnIndex == warehouseColumnIndex) { break }
                    const newCell = table.rows[elRow].cells[+columnIndex + +i]
                    // if next cell has id, that means that a card is placed in it
                    if (newCell.id) {
                        const existingElements = Array.from(document.querySelectorAll(`span[id="${newCell.id}"]`))
                        existingElements.forEach(el => {
                            const apo = +el.parentElement.getAttribute('hour').replace(/[^0-9]/g, "") + +el.parentElement.getAttribute('start')
                            const eos = +el.parentElement.getAttribute('hour').replace(/[^0-9]/g, "") + +el.parentElement.getAttribute('stop')
                            const oraStr = apo ? apo == eos ? getOrdinal(apo) + ' hour' : getOrdinal(apo) + ' to ' + getOrdinal(eos) + ' hours' : '';
                            message.push('\n' + (oraStr ? oraStr + '\n' : '') + el.parentElement.parentElement.cells[0].textContent + '\ngroup:    ' + el.getAttribute('tmima') + (el.getAttribute('room') ? '\nroom:     ' + el.getAttribute('room') : '') + '\n')
                        })
                    }
                }

            })

            // check all the others cells in affected columns if they have the same students-division or same room
            //dragElTmima.forEach(tm => {
            affectedElTmimata.forEach(tm => {
                // same students-division
                let otherCells = Array.from(document.querySelectorAll(`td[tmima*="${tm}"]`))
                    .filter(el => el.cellIndex >= columnIndex)
                    .filter(el => el.cellIndex < +columnIndex + +dragElSize)
                    .filter(el => el.id !== draggedElement.id)
                    //.filter(el => el.id)
                    .filter(el => el.getAttribute('tmima').split(',').includes(tm));

                // same room
                const otherRoomCells = Array.from(document.querySelectorAll(`td[room="${dragElRoom}"]`))
                    .filter(el => el.cellIndex >= columnIndex)
                    .filter(el => el.cellIndex < +columnIndex + +dragElSize)
                    .filter(el => el.id !== draggedElement.id)
                    .filter(el => el.getAttribute('tmima') !== tm);

                // join all together and set unique
                otherCells = Array.from(new Set([...otherCells, ...otherRoomCells]))

                otherCells.forEach(c => {

                    const cellsClear = Array.from(document.querySelectorAll(`td[id="${c.id}"]`))

                    cellsClear.forEach(el => {
                        // if they contain card the card should be removed
                        if (el.firstChild) {
                            const apo = +el.getAttribute('hour').replace(/[^0-9]/g, "") + +el.getAttribute('start')
                            const eos = +el.getAttribute('hour').replace(/[^0-9]/g, "") + +el.getAttribute('stop')
                            const oraStr = apo ? apo == eos ? getOrdinal(apo) + ' hour' : getOrdinal(apo) + ' to ' + getOrdinal(eos) + ' hours' : '';
                            message.push('\n' + (oraStr ? oraStr + '\n' : '') + el.parentElement.cells[0].textContent + '\ngroup:    ' + el.getAttribute('tmima') + (el.getAttribute('room') ? '\nroom:     ' + el.getAttribute('room') : '') + '\n')
                        }
                    })

                })

            })
            // end of 1st round

            // get unique messages of array 
            message = Array.from(new Set(message))

            // ask user to confirm
            if (message.length) {
                headMessage = `Moved activity\n\n` + (dragHour ? `${dragHour} hour\n` : '') + `${dragElTeacher}\ngroup:    ${dragElTmima}\n` + (dragElRoom ? `room:     ${dragElRoom}\n` : '') + (dragHour ? `\nfrom ${dragHour} ` : '\n') + `to ${dropHour} hour conflicts with\n`
                var ok = confirm(headMessage + message.join("") + '\nPlease confirm substitution.')
                if (!ok) {
                    removeBackground(draggedElement)
                    return
                }
            }

            // 2nd round
            // time for actions

            // clean all old cells of the dragged card 
            const cellsClear = Array.from(document.querySelectorAll(`td[id="${dragElId}"]`))
            cellsClear.forEach(el => {
                el.removeAttribute('id')
                el.removeAttribute('tmima')
                el.removeAttribute('room')
                el.removeAttribute('start')
                el.removeAttribute('stop')
                el.classList.add('spot-last-cell');
                setTimeout(() => el.classList.remove('spot-last-cell'), spotExpellDuration);
            })

            // get all cards with the same id as an array and loop
            const newDraggedElements = Array.from(document.querySelectorAll(`span[id="${draggedElement.id}"]`))
            newDraggedElements.forEach(spel => {
                let elRow = spel.getAttribute('row')
                const newCell = table.rows[elRow].cells[columnIndex]
                spel.setAttribute('col', columnIndex)
                // if drop cell has id, that means that a card is placed in it and should be moved to warehouse
                if (newCell.id) {
                    const existingElements = Array.from(document.querySelectorAll(`span[id="${newCell.id}"]`))
                    existingElements.forEach(exel => {
                        exel.setAttribute('col', warehouseColumnIndex)
                        exel.classList.remove('warn-span')
                        table.rows[exel.getAttribute('row')].cells[warehouseColumnIndex].appendChild(exel)
                    })
                    // clear all cells that had the card from the data
                    const existingElementsCells = Array.from(document.querySelectorAll(`td[id="${newCell.id}"]`))
                    existingElementsCells.forEach(exelcell => {
                        exelcell.removeAttribute('id')
                        exelcell.removeAttribute('tmima')
                        exelcell.removeAttribute('room')
                        exelcell.removeAttribute('start')
                        exelcell.removeAttribute('stop')
                        exelcell.classList.add('spot-expelled');
                        setTimeout(() => exelcell.classList.remove('spot-expelled'), spotExpellDuration);
                    })
                }
                // append the card to drop cell
                newCell.appendChild(spel)

                let chkNotAvailableCells = false

                // set data to cells depending on card size
                for (i = 0; i < dragElSize; i++) {
                    // if drop is in warehouse no need to do anything of these
                    if (columnIndex == warehouseColumnIndex) { break }

                    // get cell
                    const newCell = table.rows[elRow].cells[+columnIndex + +i]

                    // if not availiable i will mark card later
                    if (newCell.classList.contains('not-av')) { chkNotAvailableCells = true }

                    // if cell contains other card i send it to warehouse
                    if (newCell.id) {
                        const existingElements = Array.from(document.querySelectorAll(`span[id="${newCell.id}"]`))
                        existingElements.forEach(el => {
                            el.setAttribute('col', warehouseColumnIndex)
                            el.classList.remove('warn-span')
                            table.rows[el.getAttribute('row')].cells[warehouseColumnIndex].appendChild(el)
                        })
                        // remove data attributes from cells that contained previous card 
                        const existingElementsCells = Array.from(document.querySelectorAll(`td[id="${newCell.id}"]`))
                        existingElementsCells.forEach(exelcell => {
                            exelcell.removeAttribute('id')
                            exelcell.removeAttribute('tmima')
                            exelcell.removeAttribute('room')
                            exelcell.removeAttribute('start')
                            exelcell.removeAttribute('stop')
                            exelcell.classList.add('spot-expelled');
                            setTimeout(() => exelcell.classList.remove('spot-expelled'), spotExpellDuration);
                        })
                    }
                    // set data attributes to new cells
                    newCell.setAttribute('id', draggedElement.id)
                    newCell.setAttribute('tmima', dragElTmima)
                    if (dragElRoom) newCell.setAttribute('room', dragElRoom)
                    newCell.setAttribute('start', 0 - i)
                    newCell.setAttribute('stop', dragElSize - 1 - i)

                }

                // mark card if droped in not available teacher time cell
                if (chkNotAvailableCells) {
                    spel.classList.add('warn-span')
                } else {
                    spel.classList.remove('warn-span')
                }
            })


            // find all other cells with the same group in columns affected
            //dragElTmima.forEach(tm => {
            affectedElTmimata.forEach(tm => {
                // same students-division
                let otherCells = Array.from(document.querySelectorAll(`td[tmima*="${tm}"]`))
                    .filter(el => el.cellIndex >= columnIndex)
                    .filter(el => el.cellIndex < +columnIndex + +dragElSize)
                    .filter(el => el.id !== draggedElement.id)
                    //.filter(el => el.id)
                    .filter(el => el.getAttribute('tmima').split(',').includes(tm));

                // same room
                const otherRoomCells = Array.from(document.querySelectorAll(`td[room="${dragElRoom}"]`))
                    .filter(el => el.cellIndex >= columnIndex)
                    .filter(el => el.cellIndex < +columnIndex + +dragElSize)
                    .filter(el => el.id !== draggedElement.id)
                    .filter(el => el.getAttribute('tmima') !== tm);

                // join all together and set unique
                otherCells = Array.from(new Set([...otherCells, ...otherRoomCells]))

                otherCells.forEach(c => {

                    // get all cells with id that belong to previous card
                    const cellsClear = Array.from(document.querySelectorAll(`td[id="${c.id}"]`))

                    cellsClear.forEach(el => {
                        // if card is present i send it in warehouse
                        if (el.firstChild) {
                            el.firstChild.setAttribute('col', warehouseColumnIndex)
                            table.rows[el.firstChild.getAttribute('row')].cells[warehouseColumnIndex].appendChild(el.firstChild)
                        }
                        // clean data attributes
                        el.removeAttribute('id')
                        el.removeAttribute('tmima')
                        el.removeAttribute('room')
                        el.removeAttribute('start')
                        el.removeAttribute('stop')
                        el.classList.add('spot-expelled');
                        setTimeout(() => el.classList.remove('spot-expelled'), spotExpellDuration);
                    })

                })

            })

            removeBackground(draggedElement)
            clearElement(draggedElement)
            // end of 2nd round

            findMissingTmimata()
            saveTable(table)
        }

        function findMissingTmimata() {
            const table = document.getElementById('programTable')

            // find missing groups for every column
            for (i = 1; i < table.tBodies[0].rows[0].cells.length - 1; i++) {
                // start with full group array for every column
                let colGroupsArray = groupsArray

                /* 
                I DONT NEED THIS NOW. 
                JUST LEAVE THE CODE IF IS NEEDED IN FUTURE

                // find all groups in current hour
                let tmimataArr = []
                */

                // find all rooms occupied in current hour
                let roomsArr = []
                // at every row
                for (j = 0; j < table.tBodies[0].rows.length; j++) {
                    // get group
                    let toRemove = table.tBodies[0].rows[j].cells[i].getAttribute('tmima')
                    let rooms = table.tBodies[0].rows[j].cells[i].getAttribute('room')

                    // if group present i remove it from arraycolGroupsArray
                    if (toRemove) {

                        toRemove = toRemove.split(',')

                        /* I DONT NEED THIS NOW 
                        tmimataArr = [...tmimataArr, ...toRemove]
                        */

                        // add rooms to array if availiable
                        if (rooms) roomsArr = [...roomsArr, rooms]

                        colGroupsArray = colGroupsArray.filter((el) => !toRemove.includes(el));

                        for (k = 0; k < toRemove.length; k++) {
                            // if current group is Subgroup i also remove parent Group
                            if (subgroupsArray[toRemove[k]]) {
                                colGroupsArray = colGroupsArray.filter((el) => !subgroupsArray[toRemove[k]].includes(el));
                            }
                            // if current group has Subgroups i also remove these Subgroups
                            if (xmlGroupsArray[toRemove[k]]) {
                                colGroupsArray = colGroupsArray.filter((el) => !xmlGroupsArray[toRemove[k]].includes(el));
                            }
                        }

                    }

                }

                /* I DONT NEED THIS NOW 
                table.tFoot.rows[0].cells[i].setAttribute('tmimata', Array.from(new Set(tmimataArr)))
                */

                // set rooms in footer to check if occupied at current hour
                table.tFoot.rows[0].cells[i].setAttribute('rooms', Array.from(new Set(roomsArr)))

                // if groups left in array set thead and tfoot to inform user
                if (colGroupsArray.length) {
                    if (showFooter) {
                        table.tHead.rows[1].cells[i - 1].style.background = '#eeeeee'
                        table.tHead.rows[1].cells[i - 1].setAttribute('info', 'groups with no activity\n' + colGroupsArray)
                    } else {
                        table.tHead.rows[1].cells[i - 1].style.background = ''
                        table.tHead.rows[1].cells[i - 1].setAttribute('info', '')
                    }
                    table.tFoot.rows[0].cells[i].innerHTML = colGroupsArray.sort().join('<br>')
                } else {
                    table.tHead.rows[1].cells[i - 1].style.background = ''
                    table.tHead.rows[1].cells[i - 1].setAttribute('info', '')
                    table.tFoot.rows[0].cells[i].textContent = ''
                }
            }

        }

        // swaps print-noprint for specific day
        function dayNoPrint(day) {
            const table = document.getElementById('programTable')

            if (table.tHead.rows[0].cells[day].classList.contains('strike')) {

                table.tHead.rows[0].cells[day].classList.remove('no-print')
                table.tHead.rows[0].cells[day].classList.remove('strike')
                table.tHead.rows[0].cells[day].title = 'Do not print'
                for (i = 0; i < hoursLength; i++) {
                    table.tHead.rows[1].cells[(day - 1) * hoursLength + i].classList.remove('no-print')
                    for (j = 0; j < table.tBodies[0].children.length; j++) {
                        table.tBodies[0].rows[j].cells[(day - 1) * hoursLength + i + 1].classList.remove('no-print')
                    }
                }

            } else {

                table.tHead.rows[0].cells[day].classList.add('no-print')
                table.tHead.rows[0].cells[day].classList.add('strike')
                table.tHead.rows[0].cells[day].title = 'Do print'
                for (i = 0; i < hoursLength; i++) {
                    table.tHead.rows[1].cells[(day - 1) * hoursLength + i].classList.add('no-print')
                    for (j = 0; j < table.tBodies[0].children.length; j++) {
                        table.tBodies[0].rows[j].cells[(day - 1) * hoursLength + i + 1].classList.add('no-print')
                    }
                }
            }

        }

        // sends card to warehouse
        function handleDoubleClick(id) {
            const table = document.getElementById("programTable");
            const existingElements = Array.from(document.querySelectorAll(`span[id="${id}"]`))
            existingElements.forEach(el => {
                el.setAttribute('col', warehouseColumnIndex)
                el.classList.remove('warn-span')
                table.rows[el.getAttribute('row')].cells[warehouseColumnIndex].appendChild(el)
            })
            const existingElementsCells = Array.from(document.querySelectorAll(`td[id="${id}"]`))
            existingElementsCells.forEach(el => {
                el.removeAttribute('id')
                el.removeAttribute('tmima')
                el.removeAttribute('start')
                el.removeAttribute('stop')
                el.classList.add('spot-expelled');
                setTimeout(() => el.classList.remove('spot-expelled'), spotExpellDuration);
            })

            findMissingTmimata()
            saveTable(table)
        }


        // source: https://blog.stackademic.com/understanding-dom-serialization-and-parsing-in-javascript-28e8ec1acab3
        const serializeDOM = (root) => {
            if (!(root instanceof Element)) return null; // Ensure the element is a valid DOM element
            const domList = {
                childNodes: [],
                type: "element",
                tagName: root.tagName, // Get the tag name (e.g., div, p, h1)
            };
            // Loop through all the attributes of the element and add them to the serialized object
            for (const attr of root.attributes) {
                domList[attr.name] = `${attr.value}`;
            }
            // Recursively serialize child elements
            root.childNodes.forEach((node) => {
                if (node.nodeType === 1) {
                    domList.childNodes.push(serializeDOM(node)); // Serialize child elements
                } else if (node.nodeType === 3 && node.nodeValue.trim() !== "") {
                    // Serialize text nodes, but ignore empty text nodes
                    domList.childNodes.push({
                        type: "text",
                        content: node.nodeValue, // Store the content of the text node
                    });
                }
            });
            return domList; // Return the serialized DOM
        };

        // source: https://blog.stackademic.com/understanding-dom-serialization-and-parsing-in-javascript-28e8ec1acab3
        const parseDOM = (element) => {
            const { type } = element;
            if (type === "text") {
                // If it's a text node, create a text node
                const rootEle = document.createTextNode(element.content);
                return rootEle;
            }
            const { tagName, childNodes, ...props } = element;
            const rootEle = document.createElement(tagName.toLowerCase()); // Create the element based on the tag name
            // Set attributes of the element
            for (let prop of Object.keys(props)) {
                if (prop.startsWith("on")) {
                    // Handle inline event listeners
                    rootEle[prop] = new Function(props[prop]);
                } else {
                    rootEle.setAttribute(prop, props[prop]);
                }
            }
            // Recursively append child nodes
            childNodes.forEach((node) => {
                rootEle.appendChild(parseDOM(node)); // Recursively parse child elements
            });
            return rootEle; // Return the recreated DOM element
        };

        function prev() {
            let current = sessionStorage.getItem("current-table-index")
            const first = sessionStorage.getItem("first-table-index")
            if (current == first) { return }
            current--
            sessionStorage.setItem("current-table-index", current)
            const tableJson = sessionStorage.getItem('table#' + current)
            const newTable = parseDOM(JSON.parse(tableJson))
            const oldTable = document.getElementById('programTable')
            document.getElementById('tablediv').replaceChild(newTable, oldTable)

            eventListeners()
            showHidePrevNext()
            doToggleFooter()
        }

        function next() {
            let current = sessionStorage.getItem("current-table-index")
            const last = sessionStorage.getItem("last-table-index")
            if (current == last) { return }
            current++
            sessionStorage.setItem("current-table-index", current)
            const tableJson = sessionStorage.getItem('table#' + current)
            const newTable = parseDOM(JSON.parse(tableJson))
            const oldTable = document.getElementById('programTable')
            document.getElementById('tablediv').replaceChild(newTable, oldTable)

            eventListeners()
            showHidePrevNext()
            doToggleFooter()
        }

        function showHidePrevNext() {
            const first = sessionStorage.getItem("first-table-index")
            const last = sessionStorage.getItem("last-table-index")
            const current = sessionStorage.getItem("current-table-index")
            if (current == last) {
                document.getElementById('next').style.visibility = 'hidden'
            } else {
                document.getElementById('next').style.visibility = 'visible'
            }
            if (current == first) {
                document.getElementById('prev').style.visibility = 'hidden'
            } else {
                document.getElementById('prev').style.visibility = 'visible'
            }
        }

        // Get the modal
        const aboutModal = document.getElementById("aboutModal");
        // Get the button that opens the modal
        const btn = document.getElementById("aboutBtn");
        // Get the <span> element that closes the modal
        const span = document.getElementsByClassName("close")[0];

        // When the user clicks the button, open the modal 
        btn.onclick = function () {
            aboutModal.style.display = "block";
        }

        function closeAbout() {
            aboutModal.style.display = 'none';
            //window.location.reload()
        }

        // When the user clicks on <span> (x), close the modal
        span.onclick = function () {
            closeAbout()
        }

        // Get the error modal
        const errorModal = document.getElementById('errorModal');

        function showError(title, message) {
            document.getElementById('errorTitle').textContent = title;
            document.getElementById('errorMessage').textContent = message;
            errorModal.style.display = 'block';
        }

        function closeError() {
            //errorModal.style.display = 'none';
            window.location.reload()
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            if (event.target === aboutModal) {
                closeAbout();
            }
            if (event.target === errorModal) {
                closeError();
            }
        }

        // Close with ESC key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && aboutModal.style.display === 'block') {
                closeAbout();
            }
            if (event.key === 'Escape' && errorModal.style.display === 'block') {
                closeError();
            }
        });

        function toggleFooterVisible() {
            showFooter = !showFooter
            doToggleFooter()
        }

        function doToggleFooter() {
            const toggleFooter = document.getElementById('toggleFooter')
            let allFootCells = Array.from(document.querySelectorAll(`.footer`))
            allFootCells.forEach(c => {
                if (showFooter) {
                    c.classList.remove('display-none')
                    toggleFooter.title = "Toggle footer invisible"
                    toggleFooter.innerHTML = "&otimes;"
                } else {
                    c.classList.add('display-none')
                    toggleFooter.title = "Toggle footer visible"
                    toggleFooter.innerHTML = "&oplus;"
                }
            })
            findMissingTmimata()
        }

        function setTitle() {
            let title = prompt('Input title to be printed', document.getElementById('title').textContent)
            if (title == null) return
            if (!title.trim()) return
            document.getElementById('title').textContent = title.trim();
        }

        function markBorder() {
            const markBorder = Array.from(document.querySelectorAll(`.mark-border`))
            markBorder.forEach(el => {
                //if (document.documentElement.hasAttribute('dir')) {
                if (document.getElementById('tablecontainer').hasAttribute('dir')) {
                    el.style.borderLeftWidth = 'medium';
                    el.style.borderRightWidth = 'thin';
                } else {
                    el.style.borderRightWidth = 'medium';
                    el.style.borderLeftWidth = 'thin';
                }
            })
        }

        function changeDirection() {
            const direction = localStorage.getItem("direction")
            if (!direction) {
                localStorage.setItem("direction", 'rtl')
                document.getElementById('tablecontainer').setAttribute('dir', 'rtl')
            } else {
                // document.documentElement.removeAttribute('dir')
                document.getElementById('tablecontainer').removeAttribute('dir')
                localStorage.removeItem("direction")
                document.getElementById('prev').innerHTML = '&larr;'
                document.getElementById('next').innerHTML = '&rarr;'
            }
            markBorder()
        }

        // show/hide top-span with subject
        function showSubject() {
            // get all top-spans of cards that show subject
            const topSpans = Array.from(document.querySelectorAll(`.top-span`))
            topSpans.forEach(el => {
                if (el.classList.contains('display-none')) {
                    // make them visible and vertcal align bottom
                    el.classList.remove('display-none')
                    el.classList.add('display-block')
                    //el.parentElement.parentElement.style.verticalAlign = 'bottom'
                } else {
                    // make them invisible and vertical align middle
                    el.classList.remove('display-block')
                    el.classList.add('display-none')
                    el.style.fontSize = initFontSize
                    //el.parentElement.parentElement.style.verticalAlign = 'middle'
                }
            })

        }

        // add click eventListener to button [...]

        // check if clicked left - center - right
        // if center show/hide top-span with subject
        // if left reduce subject font-size
        // if right enlarge subject font-size
        const showSubjectDiv = document.getElementById('showSubject');
        showSubjectDiv.addEventListener('click', (event) => {
            // Get the bounding rectangle of the div
            const rect = showSubjectDiv.getBoundingClientRect();
            // Calculate the center X-coordinate of the div
            const leftX = rect.left + rect.width / 4;
            const rightX = rect.right - rect.width / 4;
            // Get the X-coordinate of the click
            const clickX = event.clientX;

            const topSpans = Array.from(document.querySelectorAll(`.top-span`))
            // Determine if the click was on the left or right side
            if (clickX < leftX) {
                topSpans.forEach(el => {
                    el.style.fontSize = (parseFloat(el.style.fontSize) - 0.1) + 'rem'
                    if (el.classList.contains('display-none')) { showSubject() }
                })
            } else if (clickX > rightX) {
                topSpans.forEach(el => {
                    el.style.fontSize = (parseFloat(el.style.fontSize) + 0.1) + 'rem'
                    if (el.classList.contains('display-none')) { showSubject() }
                })
            } else {
                showSubject()
            }
        });




        window.onload = () => {

            if (localStorage.getItem("direction")) {
                document.getElementById('tablecontainer').setAttribute('dir', 'rtl')
            }
        }

        // clear session 
        window.onbeforeunload = () => sessionStorage.clear()

        function createSampleTable() {

            // create new sampleTable structure
            const sampleTable = document.createElement("table");
            // add class to easy access later
            sampleTable.classList.add('print-table')

            const header = document.getElementById("programTable").tHead.cloneNode(true)
            const days = Array.from(header.firstChild.children).slice(1, header.firstChild.children.length)
            const hours = Array.from(header.lastChild.children).slice(0, hoursLength)
            // create thead and add row and cells with hour names
            const head = sampleTable.appendChild(document.createElement('thead'))
            const row = head.insertRow()
            hours.forEach(h => {
                const cell = row.appendChild(h)
                cell.removeAttribute('style')
                cell.innerText = cell.title
            })
            // create tbody add rows and first cell with day names
            sampleTable.appendChild(document.createElement('tbody'))
            days.forEach(d => {
                const row = sampleTable.tBodies[0].insertRow()
                const cell = row.appendChild(d)
                cell.removeAttribute('style')
                cell.removeAttribute('colSpan')
                //cell.title = 'Do not print'
            })
            return sampleTable
        }

        // show and print schedule per teacher
        function printTeachersSchedule() {
            // get access to programTable
            const table = document.getElementById("programTable");
            // if table is not visible we make it visible
            if (table.classList.contains('display-none')) {
                table.classList.remove('display-none')
                // set buttons visible
                document.getElementById('printTeachers').title = 'Print Teachers Schedule'
                document.getElementById('printGroups').classList.remove('display-none')
                document.getElementById('printGroups').classList.add('display-inline-block')
                document.getElementById('toggleFooter').classList.remove('display-none')
                document.getElementById('toggleFooter').classList.add('display-inline-block')
                document.getElementById('prev').classList.remove('display-none')
                document.getElementById('prev').classList.add('display-inline-block')
                document.getElementById('next').classList.remove('display-none')
                document.getElementById('next').classList.add('display-inline-block')
                // remove all printTeacher tables
                const printTeacherTables = Array.from(document.querySelectorAll(`.print-table`))
                printTeacherTables.forEach(t => {
                    table.parentElement.removeChild(t)
                })
                // set css var --tile-width to default value
                document.documentElement.style.setProperty('--tile-width', tileWidth);
                // exit
                return
            }
            // table is visible. We make it invisible
            table.classList.add('display-none')
            // set buttons invisible
            document.getElementById('printTeachers').title = 'Back'
            document.getElementById('printGroups').classList.remove('display-inline-block')
            document.getElementById('printGroups').classList.add('display-none')
            document.getElementById('toggleFooter').classList.remove('display-inline-block')
            document.getElementById('toggleFooter').classList.add('display-none')
            document.getElementById('prev').classList.remove('display-inline-block')
            document.getElementById('prev').classList.add('display-none')
            document.getElementById('next').classList.remove('display-inline-block')
            document.getElementById('next').classList.add('display-none')

            // save original value of css var --tile-width to variable
            tileWidth = window.getComputedStyle(document.body).getPropertyValue('--tile-width')
            // calculate labelWidth
            const labelWidth = parseInt(tileWidth) * 5 + 'px'

            // get sampleTable
            tableTeachers = createSampleTable()

            //get all rows of programTable
            const tableRows = Array.from(table.tBodies[0].rows)
            // loop to create table for each teacher row
            tableRows.forEach(tr => {
                // get all cells of current row of programTable
                const tableRowCells = Array.from(tr.cells)

                // clone tableTeachers
                const newTable = tableTeachers.cloneNode(true)

                // insert first cell with name of teacher
                newTable.tHead.rows[0].insertBefore(tableRowCells[0].cloneNode(true), newTable.tHead.rows[0].firstChild)
                // set style and eventListener to first cell
                const cell = newTable.tHead.rows[0].cells[0]
                cell.removeAttribute('style')
                cell.style.fontWeight = 'bold'
                cell.style.minWidth = labelWidth
                cell.style.maxWidth = labelWidth
                cell.title = "Do not print"
                cell.style.cursor = 'pointer'
                cell.style.background = '#f5fbff'
                cell.style.color = '#11496e'
                cell.addEventListener('click', () => tableNoPrint(newTable))
                cell.classList.remove('strike')

                // remove first and last cell
                tableRowCells.shift()
                tableRowCells.pop()
                // loop tableRowCells and put them in correct row
                tableRowCells.forEach((trc, ind) => {
                    // row = ABS of division index ind / hoursLength
                    const rowInd = parseInt(ind / hoursLength)
                    // append cell to exact row
                    const cell = newTable.tBodies[0].rows[rowInd].appendChild(trc.cloneNode(true))
                    cell.removeAttribute('style')
                })

                // get fisrt column cells with day names
                // add classList to access them later and eventlistener to show-hide row when printing
                const rows = Array.from(newTable.tBodies[0].rows)
                rows.forEach(r => {
                    r.cells[0].classList.add('day-print-noprint')
                    r.cells[0].addEventListener('click', () => daysPrintNoprint(r.cells[0].getAttribute('index')))
                })

                // add table to DOM
                table.parentElement.appendChild(newTable)
            })

            markBorder()
            // set --tile-width for new tables to x4
            const newTileWidth = parseInt(tileWidth) * 4
            document.documentElement.style.setProperty('--tile-width', newTileWidth + 'px');
        }

        // swaps print-noprint for specific teacher table
        function tableNoPrint(table) {

            if (table.tHead.rows[0].cells[0].classList.contains('strike')) {
                table.classList.remove('no-print')
                table.tHead.rows[0].cells[0].classList.remove('strike')
                table.tHead.rows[0].cells[0].title = 'Do not print'
            } else {
                table.classList.add('no-print')
                table.tHead.rows[0].cells[0].classList.add('strike')
                table.tHead.rows[0].cells[0].title = 'Do print'
            }
        }

        // swaps print-noprint for teacher row in programtable
        function teacherNoPrint(cell) {
            if (cell.classList.contains('strike')) {
                cell.parentElement.classList.remove('no-print')
                cell.classList.remove('strike')
                cell.title = 'Do not print'
            } else {
                cell.parentElement.classList.add('no-print')
                cell.classList.add('strike')
                cell.title = 'Do print'
            }
        }

        function daysPrintNoprint(index) {
            // get all days of printTeacherTables
            const days = Array.from(document.querySelectorAll(`.day-print-noprint`))
            days.forEach(d => {
                // if index is different continue to next
                if (d.getAttribute('index') !== index) return
                // toggle print - no-print
                if (d.classList.contains('strike')) {
                    d.classList.remove('strike')
                    d.title = 'Do not print'
                    d.parentElement.classList.remove('no-print')
                } else {
                    d.classList.add('strike')
                    d.title = 'Do print'
                    d.parentElement.classList.add('no-print')
                }
            })

        }

        function printGroupsSchedule() {
            // get access to programTable
            const table = document.getElementById("programTable");
            // if table is not visible we make it visible
            if (table.classList.contains('display-none')) {
                table.classList.remove('display-none')
                // set buttons visible
                document.getElementById('printGroups').title = "Print Groups Schedule"
                document.getElementById('printTeachers').classList.remove('display-none')
                document.getElementById('printTeachers').classList.add('display-inline-block')
                document.getElementById('toggleFooter').classList.remove('display-none')
                document.getElementById('toggleFooter').classList.add('display-inline-block')
                document.getElementById('prev').classList.remove('display-none')
                document.getElementById('prev').classList.add('display-inline-block')
                document.getElementById('next').classList.remove('display-none')
                document.getElementById('next').classList.add('display-inline-block')
                // remove all printTeacher tables
                const printTeacherTables = Array.from(document.querySelectorAll(`.print-table`))
                printTeacherTables.forEach(t => {
                    table.parentElement.removeChild(t)
                })
                // set css var --tile-width to default value
                document.documentElement.style.setProperty('--tile-width', tileWidth);
                // exit
                return
            }
            // table is visible. We make it invisible
            table.classList.add('display-none')
            // set buttons invisible
            document.getElementById('printGroups').title = 'Back'
            document.getElementById('printTeachers').classList.remove('display-inline-block')
            document.getElementById('printTeachers').classList.add('display-none')
            document.getElementById('toggleFooter').classList.remove('display-inline-block')
            document.getElementById('toggleFooter').classList.add('display-none')
            document.getElementById('prev').classList.remove('display-inline-block')
            document.getElementById('prev').classList.add('display-none')
            document.getElementById('next').classList.remove('display-inline-block')
            document.getElementById('next').classList.add('display-none')

            // save original value of css var --tile-width to variable
            tileWidth = window.getComputedStyle(document.body).getPropertyValue('--tile-width')
            // calculate labelWidth
            const labelWidth = parseInt(tileWidth) * 3 + 'px' // !!! for a reason i dont know it does not work

            tableYears = createSampleTable()

            // loop to create table for each group
            //sortedUniqueArrGroups.forEach(tm => {
            groupsArray.forEach(tm => {
                // clone tableYears
                const newTable = tableYears.cloneNode(true)
                newTable.id = 'tbl@' + tm

                // insert first cell with name of Group
                const newCell = document.createElement('td')
                newTable.tHead.rows[0].insertBefore(newCell, newTable.tHead.rows[0].firstChild)
                // set innerText, style and eventListener to first cell
                const cell = newTable.tHead.rows[0].cells[0]
                cell.innerText = tm
                cell.classList.add('mark-border')
                cell.style.fontWeight = 'bold'
                cell.style.minWidth = labelWidth
                cell.style.maxWidth = labelWidth
                cell.title = "Do not print"
                cell.style.cursor = 'pointer'
                cell.style.background = '#f5fbff'
                cell.style.color = '#11496e'
                cell.style.textAlign = 'center'
                cell.addEventListener('click', () => tableNoPrint(newTable))

                // create other cells of table
                const rows = Array.from(newTable.tBodies[0].rows)
                rows.forEach(r => {
                    r.cells[0].classList.add('day-print-noprint')
                    r.cells[0].addEventListener('click', () => daysPrintNoprint(r.cells[0].getAttribute('index')))
                    r.cells[0].style.minWidth = labelWidth
                    r.cells[0].style.maxWidth = labelWidth
                    for (i = 0; i < hoursLength; i++) {
                        const cell = r.insertCell()
                        cell.classList.add('program')
                        if (i == hoursLength - 1) cell.classList.add('mark-border')
                    }
                })

                // add table to DOM
                table.parentElement.appendChild(newTable)
            })

            // get all cards
            const allSpans = Array.from(document.querySelectorAll(`.drag-span`))
            // add cards to group tables
            allSpans.forEach(sp => {

                // clone to newCard
                const newSp = sp.cloneNode(true)

                // get column of card
                const col = newSp.getAttribute('col')

                // if card is in warehouse continue to next
                if (col == warehouseColumnIndex) return

                // set data to card spans
                const info = newSp.getAttribute('info').split('\n')
                newSp.firstChild.innerText = info[2].replace(' - ', '\n')
                newSp.firstChild.classList.remove('display-none')
                newSp.firstChild.style.fontSize = 'x-small'
                newSp.children[1].innerText = info[1]
                newSp.lastChild.classList.remove('display-none')
                newSp.lastChild.style.fontSize = 'x-small'

                // calculate cell to put card
                // row index = ABS of division index ind / hoursLength
                const rowInd = parseInt((col - 1) / hoursLength)
                // cell index = mod of division index ind / hoursLength
                const cellInd = parseInt((col - 1) % hoursLength)

                // if two groups join to a subject i put subject to every group
                const arrTableId = newSp.getAttribute('tmima').split(',')
                arrTableId.forEach(tm => {
                    if (!document.getElementById('tbl@' + tm)) {
                        console.log('missing index: ', 'tbl@' + tm)
                        return
                    }
                    // append cell to exact row
                    // if two teachers are in subject i append card only once
                    if (!document.getElementById('tbl@' + tm).tBodies[0].rows[rowInd].cells[cellInd + 1].children.length) {
                        document.getElementById('tbl@' + tm).tBodies[0].rows[rowInd].cells[cellInd + 1].appendChild(newSp.cloneNode(true))
                    }
                })
            })

            markBorder()
            // set --tile-width for new tables to x5
            const newTileWidth = parseInt(tileWidth) * 5
            document.documentElement.style.setProperty('--tile-width', newTileWidth + 'px');
        }

        function setTileWidth() {
            // save original value of css var --tile-width to variable
            tileWidth = window.getComputedStyle(document.body).getPropertyValue('--tile-width')
            let newTileWidth = prompt("Set width of cards in pixels. Default: 30", parseInt(tileWidth))
            if (!parseInt(newTileWidth)) return
            document.documentElement.style.setProperty('--tile-width', newTileWidth + 'px');
        }

        function getOrdinal(n) {
            let ord = 'th';
            if (n % 10 == 1 && n % 100 != 11) {
                ord = 'st';
            }
            else if (n % 10 == 2 && n % 100 != 12) {
                ord = 'nd';
            }
            else if (n % 10 == 3 && n % 100 != 13) {
                ord = 'rd';
            }
            return n + ord;
        }

    </script>

</body>

</html>
