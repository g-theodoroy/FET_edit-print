<!-- 

This "program" was created in February 2025 by
    George Theodoroy
    g.theodoroy[at]gmail.com 

It is provided as is under "MIT License"
    https://opensource.org/license/mit

-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FET - edit + print</title>
    <style>
        :root {
            --tile-width: 30px;
            --padding: 0.75px;
            --margin: 0.75px;
            --font-size: 16px;
            --body-y-margin: 30px;
            --rotate: 15deg;
        }

        body {
            font-family: Arial, sans-serif;
            font-size: var(--font-size);
            font-weight: normal;
            margin-top: var(--body-y-margin);
            margin-bottom: var(--body-y-margin);
        }

        .container {
            background-color: #f5fbff;
            color: #11496e;
            height: 230px;
            width: 500px;
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #2b375e;
            border-radius: 10px;
            text-align: center;
        }

        h1 {
            margin-top: 50px;
            font-size: 45px;
        }

        table {
            border-collapse: collapse;
            margin-top: 25px;
        }

        th,
        td {
            border: 1px solid black;
            padding-bottom: var(--padding);
            padding-left: var(--padding);
            padding-right: var(--padding);
            margin-bottom: var(--margin);
            --mf: 2;
            min-width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * var(--mf))));
        }

        td.hour {
            --mf: 2;
            max-width: calc(var(--tile-width) + var(--padding) * var(--mf) + var(--margin) * (var(--mf) + 1));
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        td.program {
            --mf: 2;
            max-width: calc(var(--tile-width) + var(--padding) * var(--mf) + var(--margin) * (var(--mf) + 1));
        }

        td.text-center {
            text-align: center;
        }

        td.text-small {
            font-size: calc(var(--font-size)*5/6);
        }

        td.not-av {
            background-image: radial-gradient(circle, rgb(196, 206, 218) 2px, #fff 2px);
        }

        span {
            width: var(--tile-width);
        }

        span.w-2 {
            --mf: 2;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + var(--margin) * var(--mf)) * var(--mf))
        }

        span.w-3 {
            --mf: 3;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * (var(--mf) - 1))) * var(--mf))
        }

        span.w-4 {
            --mf: 4;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * (var(--mf) - 1))) * var(--mf))
        }

        span.w-5 {
            --mf: 5;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * (var(--mf) - 1))) * var(--mf))
        }

        td.w-3 {
            --mf: 6;
            width: calc((var(--tile-width) + (var(--padding) * var(--mf)) + (var(--margin) * (var(--mf) + 1))) * var(--mf))
        }

        .drag-span {
            background-color: #e3f2fd;
            padding: var(--padding);
            margin: var(--margin);
            cursor: move;
            border: 1px solid #90caf9;
            border-radius: 4px;
            user-select: none;
            text-align: center;
            /* overflow: hidden; */
        }

        .warn-span {
            border-bottom: 3px solid #b80404;
        }

        .display-block {
            display: block;
        }

        .display-inline-block {
            display: inline-block;
        }

        .display-none {
            display: none;
        }

        .dragging {
            opacity: 0.8;

            /*	for IE  */
            transform: rotate(var(--rotate));
            -ms-transform: rotate(var(--rotate));

            /* 	for browsers supporting webkit (such as chrome, firefox, safari etc.). */
            -webkit-transform: rotate(var(--rotate));
            display: inline-block;
        }

        .highlight {
            background-color: #ddf314;
        }

        .spot-expelled {
            background-color: #fdc9c9;
        }

        .spot-last-cell {
            background-color: #eff7a7;
        }

        .no-drag {
            pointer-events: none;
        }

        td.warehouse {
            border: none;
            min-width: calc(var(--tile-width)*3);
            background-color: #fafafa;
        }

        td.warehouse>* {
            vertical-align: middle;
        }

        td.footer {
            border: none;
            padding-top: 5px;
            font-size: 10px;
            color: #6c6d6e;
            text-align: center;
            vertical-align: top;
            max-width: var(--tile-width);
            word-wrap: break-word;
            background-color: #fafafa;
        }

        div.whiteboard {
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: normal;
            font-size: 16px;
            background-color: #fafafa;
            padding: 5px;
            margin: var(--margin);
            border-radius: 4px;
            border: 1px solid;
            border-color: #eeeeee;
        }

        td.strike {
            text-decoration: line-through;
        }

        #tablediv {
            display: inline-block;
            margin: auto;
        }

        #undo-redo {
            position: fixed;
            top: 2px;
            left: 5px;
        }

        .undo-redo-button {
            margin: 0px 2px 0px 2px;
            padding: 0px 5px 0px 5px;
            background-color: #fafafa;
            border-radius: 4px;
            border: 1px solid;
            border-color: #eeeeee;
            cursor: pointer;
        }

        #tablecontainer {
            display: flex;
        }

        .gth {
            position: fixed;
            bottom: 1px;
            left: 50%;
            transform: translateX(-50%);
            color: rgb(155, 155, 155);
            text-align: center;
            text-decoration: none;
            font-size: 12px;
        }

        .a-gth {
            color: inherit;
            text-decoration: none;
        }

        @media print {
            .no-print {
                display: none;
            }

            .print-table {
                page-break-inside: avoid !important;
            }
        }

        /* The Modal (background) */
        .modal {
            display: none;
            /* Hidden by default */
            position: fixed;
            /* Stay in place */
            z-index: 1;
            /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
            overflow: auto;
            /* Enable scroll if needed */
            background-color: rgba(0, 0, 0, 0.4);
            /* Black w/ opacity */
        }

        /* Modal Content/Box */
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            /* Could be more or less, depending on screen size */
            max-width: 600px;
            border-radius: 5px;
        }

        /* Close Button */
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: normal;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* Modal Header */
        .modal-header {
            padding: 10px 0;
            border-bottom: 1px solid #ddd;
        }

        /* Modal Body */
        .modal-body {
            padding: 15px 0;
        }

        /* Error Modal Styles */
        .error-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .error-modal-content {
            background-color: #ffe6e6;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #ff4444;
            width: 80%;
            max-width: 500px;
            border-radius: 5px;
            position: relative;
        }

        .error-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            color: #cc0000;
        }

        .error-icon {
            font-size: 24px;
            margin-right: 10px;
        }

        .error-title {
            font-size: 20px;
            font-weight: normal;
        }

        .error-message {
            margin: 10px 0;
            color: #333;
        }

        .error-close-btn {
            background-color: #cc0000;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .error-close-btn:hover {
            background-color: #b30000;
        }

        .top-span {
            width: 100%;
            overflow: hidden;
        }

        .bottom-span {
            display: block;
            width: 100%;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="container" class="container">
        <h1>FET - edit + print</h1>
        <p>Please input a locked (data_and_timetable) fet file</p>
        <input type="file" id="xmlFileInput" accept=".fet">
    </div>

    <div id="undo-redo">
        <div id="refresh" onclick="window.location.reload()" class="undo-redo-button display-inline-block no-print"
            title="Reload">&#10227;</div>
        <div id="aboutBtn" class="undo-redo-button display-inline-block no-print" title="About">&quest;</div>
        <div id="rtl" onclick="changeDirection()" class="undo-redo-button display-none no-print show-hide"
            title="Change direction">&harr;</div>
        <div id="down" onclick="downloadXml()" class="undo-redo-button display-none no-print show-hide"
            title="Download fet file">&dArr;</div>
        <div id="toggleFooter" onclick="toggleFooterVisible()" class="undo-redo-button display-none no-print show-hide"
            title="Toggle footer visible">&oplus;</div>
        <div id="showSubject" class="undo-redo-button display-none no-print show-hide"
            title="Show/Hide subject&#10;Click left - right&#10;to set font size">&nbsp;&ctdot;&nbsp;
        </div>
        <div id="setTileWidth" onclick="setTileWidth()" class="undo-redo-button display-none no-print show-hide"
            title="Set width of cards">&harr;
        </div>
        <div id="setTitle" onclick="setTitle()" class="undo-redo-button display-none no-print show-hide"
            title="Set title">&#9997;</div>
        <div id="printTeachers" onclick="printTeachersSchedule()"
            class="undo-redo-button display-none no-print show-hide" title="Print Teachers Schedule">T</div>
        <div id="printGroups" onclick="printGroupsSchedule()" class="undo-redo-button display-none no-print show-hide"
            title="Print Groups Schedule">G</div>
        <div id="prev" onclick="prev()" class="undo-redo-button display-none no-print show-hide" title="Undo">&larr;
        </div>
        <div id="next" onclick="next()" class="undo-redo-button display-none no-print show-hide" title="Redo">&rarr;
        </div>
    </div>

    <div id="tablecontainer">
        <div id="tablediv">
            <h2 id='title'>&nbsp;</h2>

            <table id="programTable">
                <thead></thead>
                <tbody></tbody>
                <tfoot></tfoot>
            </table>
        </div>

        <div class="gth  no-print">
            <span>copyright: George Theodoroy, licence: MIT Licence, mail: </span>
            <a class="a-gth" href="mailto:g.theodoroy@gmail.com?subject=FET-edit+print"
                title="mail to: George Theodoroy">GΘ@2025</a>
        </div>

    </div>

    <div id="whiteboard" class="whiteboard display-none"></div>

    <!-- The Modal -->
    <div id="aboutModal" class="modal">
        <!-- Modal content -->
        <div class="modal-content">
            <div class="modal-header">
                <span class="close">&times;</span>
                <h2>About FET - edit + print</h2>
            </div>
            <div class="modal-body">
                <p>This "program" was created in February 2025 by:</p>
                <blockquote>
                    <p>George Theodoroy</p>
                </blockquote>
                <blockquote>
                    <p>email: g.theodoroy&commat;gmail.com</p>
                </blockquote>
                <p>It is provided as is under "MIT License": https://opensource.org/license/mit</p>

                <p>&nbsp;</p>

                <p>FET - edit + print is free. If you like you can treat me a coffee ...</p>

                <form action="https://www.paypal.com/donate" method="post" target="_blank" style="text-align: center">
                    <input type="hidden" name="hosted_button_id" value="C2VEYT3GPPNY4">
                    <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
                        name="submit" title="PayPal - The safer, easier way to pay online!"
                        alt="Donate with PayPal button">
                    <!-- <img alt="" border="0" src="https://www.paypal.com/en_GR/i/scr/pixel.gif" width="1" height="1" /> -->
                </form>

            </div>
        </div>
    </div>

    <div id="errorModal" class="error-modal">
        <div class="error-modal-content">
            <div class="error-header">
                <div class="error-icon">&#9888;</div>
                <div class="error-title" id="errorTitle"></div>
            </div>
            <div class="error-message" id="errorMessage"></div>
            <button class="error-close-btn" onclick="closeError()">OK</button>
        </div>
    </div>

    <script>

        // global variables
        let loadedXml = null;
        let xmlName = null;
        let draggedElement = null;
        let warehouseColumnIndex = null;
        let hoursLength = null
        const daysIndexList = {}
        const hoursIndexList = {}
        let groupsArray = []
        let xmlGroupsArray = []
        let subgroupsArray = []
        let noTeacher = false;
        let showFooter = false;
        let tileWidth = null;
        let initFontSize = '0.4rem';
        const showColors = true
        const spotExpellDuration = 7000
        const excludeInactiveActivities = true
        const whiteboard = document.getElementById('whiteboard')


        // NN -> NodeName
        let NN_DAY = 'Preferred_Day'
        let NN_HOUR = 'Preferred_Hour'

        // removes lightgreen background of row and green background of cells
        const removeBackground = (cell) => {
            draggedElement.parentElement.parentElement.parentElement.rows[draggedElement.getAttribute('row')].style.background = ''
            Array.from(draggedElement.parentElement.parentElement.parentElement.rows[draggedElement.getAttribute('row')].cells)
                .forEach(c => c.style.background = '')
        }

        // sets lightgreen background to teacher row 
        // sets green background to cells where student-class is missing
        const setBackgroundGreen = (cell) => {
            const table = document.getElementById('programTable')
            const theRow = draggedElement.getAttribute('row')

            const dragElTmima = draggedElement.getAttribute('tmima').split(',')
            const dragElRoom = draggedElement.getAttribute('room')

            table.tBodies[0].rows[theRow].style.background = '#cfffd7'

            // find possible positions from missing groups stored in footer cell
            const possiblePositions = Array.from(table.tFoot.rows[0].cells).filter(c => c.innerText !== '')
            possiblePositions.forEach(p => {
                let pTmimata = p.innerHTML.split('<br>')
                let chkInludes = true
                dragElTmima.forEach(t => {
                    if (!pTmimata.includes(t)) chkInludes = false
                })

                if (chkInludes) {
                    // if cell marked not-availiable for teacher continue
                    if (table.tBodies[0].rows[theRow].cells[p.cellIndex].classList.contains('not-av')) { return }
                    // if room of dragged element is occupied by other group continue
                    if (dragElRoom && table.tFoot.rows[0].cells[p.cellIndex].getAttribute('rooms').split(',').includes(dragElRoom)) { return }
                    // if drop in cell is not allowed continue
                    if (!allowDrop(table.tBodies[0].rows[theRow].cells[p.cellIndex])) { return }

                    // all free (group and room). Mark green 
                    table.tBodies[0].rows[theRow].cells[p.cellIndex].style.background = 'green'
                }
            })
        }

        // add event listener to file element
        document.getElementById('xmlFileInput').addEventListener('change', handleFileSelect, false);

        function handleFileSelect(event) {

            const file = event.target.files[0];
            if (!file) return;

            // set name of file for later use
            xmlName = file.name

            // read fet file
            const reader = new FileReader();

            reader.onload = function (e) {
                try {

                    const xmlContent = e.target.result;
                    const xmlDoc = new window.DOMParser().parseFromString(xmlContent, "text/xml")
                    // Check for parsing errors
                    const errorNodes = xmlDoc.getElementsByTagName("parsererror");
                    if (errorNodes.length > 0) {
                        throw new Error('Error parsing XML');
                    }

                    // Process the XML
                    displayXMLContent(xmlDoc);

                    // Store modified XML
                    const serializer = new XMLSerializer();
                    loadedXml = serializer.serializeToString(xmlDoc);

                } catch (error) {
                    console.log(`Error: ${error.message}`);
                    showError('Error', 'Error reading - loading data from "' + xmlName + '".')
                }
            };

            reader.onerror = function () {
                console.log('Error reading file');
                showError('Error', 'Error reading - loading data from "' + xmlName + '".')
            };

            reader.readAsText(file);

            // save filename for later use
            xmlName = file.name

            // set UI - set title - show-hide buttons first-screen
            document.getElementById('xmlFileInput').value = '';
            document.getElementById('container').style.display = 'none';
            document.getElementById('title').textContent = file.name;
            // loop through buttons with class 'show-hide' and set them visible
            const showHide = Array.from(document.querySelectorAll(`.show-hide`))
            showHide.forEach(el => {
                el.classList.remove('display-none')
                el.classList.add('display-inline-block')
            })
        }

        // Download modified XML
        function downloadXml() {
            if (!loadedXml) {
                alert('Please load an XML file first!');
                return;
            }

            // load xml to DOM
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(loadedXml, "application/xml");

            // get all ConstraintActivityPreferredStartingTime
            const ConstraintActivityPreferredStartingTime = xmlDoc.evaluate('//fet/Time_Constraints_List/ConstraintActivityPreferredStartingTime', xmlDoc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);

            // get all cards
            let allSpans = Array.from(document.querySelectorAll(`.drag-span`))

            for (i = 0; i < ConstraintActivityPreferredStartingTime.snapshotLength; i++) {
                xmlElement = ConstraintActivityPreferredStartingTime.snapshotItem(i)
                // get Activity_Id and find spans with the same id
                const id = xmlElement.getElementsByTagName('Activity_Id')[0].textContent
                const span = allSpans.filter(sp => sp.id == id)

                // cards with same id might be 1 or 2 ( 2 when are 2 teacher at a class)
                // remove items to finally track if all of them are processed 
                for (j = 0; j < span.length; j++) {
                    allSpans.splice(allSpans.indexOf(span[j]), 1)
                }

                // in case of Activities with Active = false that we don't load
                // might be ConstraintActivityPreferredStartingTime but no card
                // so if no span[0] bypass
                if (!span[0]) continue

                // every cell (span.parenElement) has attributes of Day and Hour
                // warehouse cells have not
                // if cell has Day and Hour card is in program. Set values to xml
                if (span[0].parentElement.getAttribute('day')) {
                    xmlElement.getElementsByTagName(NN_DAY)[0].textContent = span[0].parentElement.getAttribute('day')
                    xmlElement.getElementsByTagName(NN_HOUR)[0].textContent = span[0].parentElement.getAttribute('hour')
                } else {
                    // if no Day (warehouse) remove node element from xml
                    xmlElement.parentElement.removeChild(xmlElement);
                }
            }

            // if allSpans contains entries must append them to xml

            // filter to exclude cards in warehouse
            allSpans = allSpans.filter(sp => !(sp.getAttribute('col') == warehouseColumnIndex))

            //remove the remaining double card of cards with same id (2 teachers in 1 class)
            let toRemove = []
            for (i in allSpans) {
                // find cards with same id 
                sameIdSpans = allSpans.filter(sp => sp.id == allSpans[i].id)
                if (sameIdSpans.length > 1) {
                    // if they are more than one it means that two teachers are in the same class
                    // i save as key => value card.id => index to remove
                    toRemove[allSpans.findIndex(item => item.id === sameIdSpans[1].id)] = i
                }
            }
            //  sort descending to avoid array index undefined
            var keys = Object.keys(toRemove).sort(function (a, b) { return b - a; });
            for (var i = 0; i < keys.length; i++) {
                allSpans.splice(toRemove[keys[i]], 1);
            }

            // append remaining allSpans entries to xml

            // <ConstraintActivityPreferredStartingTime>
            // 	 <Weight_Percentage>100</Weight_Percentage>
            // 	 <Activity_Id>134</Activity_Id>
            // 	 <Preferred_Day>Πε</Preferred_Day>  - after version 7.1.4 <Day>Πε</Day>
            // 	 <Preferred_Hour>2</Preferred_Hour> - after version 7.1.4 <Hour>Πε</Hour>
            // 	 <Permanently_Locked>false</Permanently_Locked>
            // 	 <Active>true</Active>
            // 	 <Comments></Comments>
            // </ConstraintActivityPreferredStartingTime>

            const TimeConstraintsList = xmlDoc.getElementsByTagName('Time_Constraints_List')

            for (i = 0; i < allSpans.length; i++) {
                const newElem = xmlDoc.createElement("ConstraintActivityPreferredStartingTime");

                let newElemChild = xmlDoc.createElement("Weight_Percentage");
                let newText = xmlDoc.createTextNode(100);
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement("Activity_Id");
                newText = xmlDoc.createTextNode(allSpans[i].id);
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement(NN_DAY);
                newText = xmlDoc.createTextNode(allSpans[i].parentElement.getAttribute('day'));
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement(NN_HOUR);
                newText = xmlDoc.createTextNode(allSpans[i].parentElement.getAttribute('hour'));
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement("Permanently_Locked");
                newText = xmlDoc.createTextNode('false');
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement("Active");
                newText = xmlDoc.createTextNode('true');
                newElemChild.appendChild(newText)
                newElem.appendChild(newElemChild)

                newElemChild = xmlDoc.createElement("Comments");
                newElem.appendChild(newElemChild)

                TimeConstraintsList[0].appendChild(newElem)

            }

            // ask user to confirm if he/she wants to set all time constraints to inactive
            var ok = confirm('Disable all unnecessary constrains?\nPlease confirm.')
            if (ok) {

                // Time_Constraints_List
                // set all Time_Constraints_List to inactive
                // except - ConstraintBasicCompulsoryTime - ConstraintActivityPreferredStartingTime
                const xmlTimeElements = xmlDoc.evaluate('//fet/Time_Constraints_List', xmlDoc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                for (i = 0; i < xmlTimeElements.snapshotItem(0).children.length; i++) {
                    if (xmlTimeElements.snapshotItem(0).children[i].localName == 'ConstraintBasicCompulsoryTime') { continue }
                    if (xmlTimeElements.snapshotItem(0).children[i].localName == 'ConstraintActivityPreferredStartingTime') { continue }
                    xmlTimeElements.snapshotItem(0).children[i].getElementsByTagName('Active')[0].textContent = 'false'
                }

                // Space_Constraints_List
                // set all Space_Constraints_List to inactive
                // except - ConstraintBasicCompulsorySpace
                const xmlSpaceElements = xmlDoc.evaluate('//fet/Space_Constraints_List', xmlDoc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                for (i = 0; i < xmlSpaceElements.snapshotItem(0).children.length; i++) {
                    if (xmlSpaceElements.snapshotItem(0).children[i].localName == 'ConstraintBasicCompulsorySpace') { continue }
                    xmlSpaceElements.snapshotItem(0).children[i].getElementsByTagName('Active')[0].textContent = 'false'
                }
            }

            // pretty format modified XML
            const serializer = new XMLSerializer();
            XmlDownload = prettyFormatXml(serializer.serializeToString(xmlDoc))
            XmlDownload = '\ufeff' + XmlDownload + '\n';

            // send it for download
            const blob = new Blob([XmlDownload], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;

            // add _edit_print to filename
            const ext = xmlName.slice(xmlName.lastIndexOf("."))
            const name = xmlName.slice(0, xmlName.lastIndexOf(".")) + '_edit_print'

            a.download = name + ext;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // format xml (it is not elegant but does the job)
        /* the desired result
          <ConstraintActivityPreferredStartingTime>
            <Weight_Percentage>100</Weight_Percentage>
            <Activity_Id>134</Activity_Id>
            <Preferred_Day>Πε</Preferred_Day>  - after version 7.1.4 <Day>Πε</Day>
            <Preferred_Hour>2</Preferred_Hour> - after version 7.1.4 <Hour>Πε</Hour>
            <Permanently_Locked>false</Permanently_Locked>
            <Active>true</Active>
            <Comments/>
          </ConstraintActivityPreferredStartingTime>
        */
        function prettyFormatXml(xml) {
            xml = xml.replace(/\n{2,}/g, '\n');
            xml = xml.replace(/(<ConstraintActivityPreferredStartingTime>)(<)/g, '  $1\n      $2')
            xml = xml.replace(/(<\/Weight_Percentage>)(<)/g, '$1\n      $2')
            xml = xml.replace(/(<\/Activity_Id>)(<)/g, '$1\n      $2')
            let re = new RegExp(String.raw`(<\/${NN_DAY}>)(<)`, "g");
            xml = xml.replace(re, '$1\n      $2')
            re = new RegExp(String.raw`(<\/${NN_HOUR}>)(<)`, "g");
            xml = xml.replace(re, '$1\n      $2')
            xml = xml.replace(/(<\/Permanently_Locked>)(<)/g, '$1\n      $2')
            xml = xml.replace(/(<\/Active>)(<)/g, '$1\n      $2')
            xml = xml.replace(/(<Comments\/>)(<)/g, '$1\n    $2')
            xml = xml.replace(/(<\/ConstraintActivityPreferredStartingTime>)(\s*<)/g, '$1\n  $2')
            return xml
        }

        function displayXMLContent(xml) {

            // get version of fet. If version is greater from 7.1.3 change NodeName NN_DAY & NN_HOUR
            const version = parseFloat(xml.getElementsByTagName("fet")[0].getAttribute('version').replace(/(?<=\..*)\./g, ''))
            if (version > 7.13) {
                NN_DAY = 'Day'
                NN_HOUR = 'Hour'
            }

            // read data from xml
            const NumOfDays = xml.getElementsByTagName("Number_of_Days")[0].textContent;
            const NumOfHours = xml.getElementsByTagName("Number_of_Hours")[0].textContent;
            const tableColNum = NumOfDays * NumOfHours + 1

            // read days
            const daysList = xml.getElementsByTagName("Days_List");
            const days = daysList[0].getElementsByTagName("Day");
            // make array of [dayName] = index
            for (let i = 0; i < days.length; i++) {
                daysIndexList[days[i].getElementsByTagName("Name")[0].textContent] = i
            }

            // read hours
            const hoursList = xml.getElementsByTagName("Hours_List");
            const hours = hoursList[0].getElementsByTagName("Hour");
            hoursLength = hours.length
            // make array of [hourName] = index
            for (let i = 0; i < hoursLength; i++) {
                hoursIndexList[hours[i].getElementsByTagName("Name")[0].textContent] = i
            }

            // read teachers
            let teachersArray = []
            const teachersList = xml.getElementsByTagName("Teachers_List");
            const teachers = teachersList[0].getElementsByTagName("Teacher");
            // arrays of teacherData - teacherColor
            for (let i = 0; i < teachers.length; i++) {
                let randomColor = Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                while (!isLightColor(randomColor)) {
                    randomColor = Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                }
                const teacherName = teachers[i].getElementsByTagName("Name")[0].textContent
                teachersArray.push({ 'name': teacherName, 'color': `#${randomColor}` })
            }

            // read teachers not available times
            const teachersNotAvailable = xml.getElementsByTagName("ConstraintTeacherNotAvailableTimes");
            for (let i = 0; i < teachersNotAvailable.length; i++) {
                if (teachersNotAvailable[i].getElementsByTagName("Active")[0].textContent == 'false') continue
                const teacherNA = teachersNotAvailable[i].getElementsByTagName("Teacher")[0].textContent
                const countNA = teachersNotAvailable[i].getElementsByTagName("Number_of_Not_Available_Times")[0].textContent
                const timesNA = teachersNotAvailable[i].getElementsByTagName("Not_Available_Time")
                const colsNA = []
                const teacherIndex = teachersArray.findIndex(t => t.name == teacherNA)

                for (let j = 0; j < timesNA.length; j++) {
                    const d = timesNA[j].getElementsByTagName("Day")[0].textContent
                    const h = timesNA[j].getElementsByTagName("Hour")[0].textContent
                    const colNA = daysIndexList[d] * NumOfHours + hoursIndexList[h] + 1
                    colsNA.push(colNA)
                }
                teachersArray[teacherIndex]['colsNA'] = colsNA
            }


            // read Croups from fet file
            // create array of Subgroups for each Group
            const xmlGroups = xml.getElementsByTagName("Group");
            for (let i = 0; i < xmlGroups.length; i++) {
                const subgroup = xmlGroups[i].getElementsByTagName("Subgroup")
                const dummyArr = []
                for (let y = 0; y < subgroup.length; y++) {
                    dummyArr.push(subgroup[y].getElementsByTagName("Name")[0].textContent)
                }
                if (dummyArr.length) {
                    xmlGroupsArray[xmlGroups[i].getElementsByTagName("Name")[0].textContent] = dummyArr
                }
            }

            // read Subroups
            // create array of each Subgroup with its parent Group
            const subgroups = xml.getElementsByTagName("Subgroup");
            for (let i = 0; i < subgroups.length; i++) {
                subgroupsArray[subgroups[i].getElementsByTagName("Name")[0].textContent] = [
                    subgroups[i].getElementsByTagName("Name")[0].textContent,
                    subgroups[i].parentElement.getElementsByTagName("Name")[0].textContent
                ]
            }

            // read activities
            // read STUDENTS from ACTIVITIES so i don't care if students come FROM YEAR or GROUP or SUBGROUP
            const activities = xml.getElementsByTagName("Activity");
            const objAct = {}

            for (let i = 0; i < activities.length; i++) {

                // const excludeInactiveActivities is set in line 495
                // if true we dont import inactive activities
                if (excludeInactiveActivities) {
                    // if activity Active = false bypass
                    if (activities[i].getElementsByTagName("Active")[0].textContent !== 'true') continue
                }

                // teachers might be one or two so i make an array of them
                const teachers = activities[i].getElementsByTagName("Teacher")
                let teacherArray = []
                for (let j = 0; j < teachers.length; j++) {
                    teacherArray.push(teachers[j].textContent)
                }
                let teacherStr = teacherArray.join(' - ')

                const subject = activities[i].getElementsByTagName("Subject")[0].textContent
                const tmimata = activities[i].getElementsByTagName("Students")
                // groups might be one or two so so i make an array of them
                const tmimaArray = []
                for (let j = 0; j < tmimata.length; j++) {
                    tmimaArray.push(tmimata[j].textContent)
                }
                const tmima = tmimaArray.join(' ')

                // read groups of Students in activities and create array of them
                groupsArray = groupsArray.concat(tmimaArray)

                const duration = activities[i].getElementsByTagName("Duration")[0].textContent
                const totalDuration = activities[i].getElementsByTagName("Total_Duration")[0].textContent
                const id = activities[i].getElementsByTagName("Id")[0].textContent

                objAct[id] = {
                    'duration': duration,
                    'totalDuration': totalDuration,
                    'tmimata': tmimaArray,
                    'tmima': tmima,
                    'teacher': teacherArray,
                    'teacherStr': teacherStr,
                    'subject': subject
                }

                if (!teachers.length) noTeacher = true
            }

            if (noTeacher) {
                teachersArray.push({ 'name': 'notAv' })
            }

            // keep values of groupsArray only once ( unique)
            let uniqueArrGroups = []
            groupsArray.forEach(el => {
                if (!uniqueArrGroups.includes(el)) {
                    uniqueArrGroups.push(el)
                }
            })
            // final groupsArray = sorted uniqueArrGroups
            groupsArray = uniqueArrGroups.sort()


            // read rooms and add them in objAct
            const activitiesRooms = xml.getElementsByTagName("ConstraintActivityPreferredRoom");

            for (let i = 0; i < activitiesRooms.length; i++) {

                // load only "Active = true" ConstraintActivityPreferredStartingTime
                if (activitiesRooms[i].getElementsByTagName("Active")[0].textContent == "false") continue

                const id = activitiesRooms[i].getElementsByTagName("Activity_Id")[0].textContent

                // if activity Active = false is bypassed and there is no id
                // so we don,t add the card
                if (!objAct[id]) continue

                objAct[id].room = activitiesRooms[i].getElementsByTagName("Room")[0].textContent
            }


            // remove from schedule teachers with no activities
            teachersArray = teachersArray.filter(t => {
                let check = false
                for (let index in objAct) {
                    // objAct[index].teacher is Array. loop for each teacher name
                    objAct[index].teacher.forEach(name => {
                        if (t.name == name) check = true
                    })
                    if (check) break
                }
                return check
            })


            // read activities start times
            const activitiesStartTimes = xml.getElementsByTagName("ConstraintActivityPreferredStartingTime");
            const objActivitiesStartTimes = []

            for (let i = 0; i < activitiesStartTimes.length; i++) {

                // load only "Active = true" ConstraintActivityPreferredStartingTime
                if (activitiesStartTimes[i].getElementsByTagName("Active")[0].textContent == "false") continue

                const id = activitiesStartTimes[i].getElementsByTagName("Activity_Id")[0].textContent

                // if activity Active = false is bypassed and there is no id
                // so we don,t add the card
                if (!objAct[id]) continue

                const d = activitiesStartTimes[i].getElementsByTagName(NN_DAY)[0].textContent
                const h = activitiesStartTimes[i].getElementsByTagName(NN_HOUR)[0].textContent
                const teacherArr = objAct[id].teacher
                // if teacher present
                if (teacherArr.length) {
                    // set row, col, data for every teacher 
                    for (j = 0; j < teacherArr.length; j++) {
                        const idx = teachersArray.findIndex(t => t.name == teacherArr[j])
                        const rowSet = idx + 2
                        const colSet = daysIndexList[d] * NumOfHours + hoursIndexList[h] + 1
                        objActivitiesStartTimes.push({
                            'id': id,
                            'r': rowSet,
                            'c': colSet,
                            'data': objAct[id],
                            'color': teachersArray[idx].color
                        })
                    }

                } else {
                    // no teacher
                    const rowSet = teachersArray.lenght - 1 + 2
                    const colSet = daysIndexList[d] * NumOfHours + hoursIndexList[h] + 1
                    objActivitiesStartTimes.push({
                        'id': id,
                        'r': rowSet,
                        'c': colSet,
                        'data': objAct[id] //? objAct[id] : {}
                    })

                }
            }



            // -------- create table ------------
            const table = document.getElementById("programTable");
            const thead = table.tHead
            const tbody = table.tBodies[0]
            const tfoot = table.tFoot

            let row = tfoot.insertRow()
            for (i = 0; i < tableColNum; i++) {
                let cell = row.insertCell()
                cell.setAttribute('col', i)
                cell.classList.add('footer', 'no-print', 'display-none')
            }


            // 1st row ------
            row = thead.insertRow();
            // title of table
            cell = row.insertCell()
            cell.rowSpan = 2
            cell.textContent = "FET - edit + print";
            cell.classList.add('mark-border')
            cell.style.background = '#f5fbff'
            cell.style.textAlign = 'center'
            cell.style.fontSize = '20px'
            cell.style.color = '#11496e'
            // date names
            for (let i = 0; i < days.length; i++) {
                const dayShort = days[i].getElementsByTagName("Name")[0].textContent;
                const dayLong = days[i].getElementsByTagName("Long_Name")[0].textContent;
                const dateName = dayLong ? dayLong : dayShort;
                let cell = row.insertCell()
                cell.colSpan = NumOfHours
                cell.textContent = dateName
                cell.classList.add('text-center', 'day')
                cell.classList.add('mark-border')
                cell.style.cursor = 'pointer'
                cell.title = 'Do not print'
            }

            // 2nd row -----
            row = thead.insertRow();

            // hour names
            for (let i = 0; i < days.length; i++) {
                for (let j = 0; j < hours.length; j++) {
                    const hourShort = hours[j].getElementsByTagName("Name")[0].textContent;
                    const hourLong = hours[j].getElementsByTagName("Long_Name")[0].textContent;
                    const glue = hourShort && hourLong ? '\n ' : '';
                    const hourName = hourShort + glue + hourLong
                    cell = row.insertCell()
                    cell.textContent = hours[j].getElementsByTagName("Name")[0].textContent
                    cell.title = hourName
                    cell.classList.add('text-center', 'hour')

                    if (j == hours.length - 1) {
                        cell.classList.add('mark-border')
                    }
                }
            }

            // 3rd row and after -----
            // enter schedule data

            for (let i = 0; i < teachersArray.length; i++) {
                let row = tbody.insertRow();
                // 1st column - teacher names
                cell = row.insertCell()
                cell.textContent = teachersArray[i].name == 'notAv' ? '' : teachersArray[i].name
                cell.classList.add('text-small')
                cell.classList.add('mark-border')
                cell.classList.add('teacher-name')
                cell.title = "Do not print"
                cell.style.cursor = 'pointer'
                // cells of schedule
                for (let j = 0; j < days.length; j++) {
                    for (let k = 0; k < hours.length; k++) {
                        cell = row.insertCell()
                        cell.classList.add('program')
                        if (k == hours.length - 1) {
                            cell.classList.add('mark-border')
                        }
                        // set to every cell values of day and hour to be accesible later
                        cell.setAttribute('row-idx', row.rowIndex - thead.childElementCount)
                        cell.setAttribute('col-idx', cell.cellIndex)
                        cell.setAttribute('day', days[j].getElementsByTagName("Name")[0].textContent)
                        cell.setAttribute('hour', hours[k].getElementsByTagName("Name")[0].textContent)
                    }
                }
                // warehouse
                cell = row.insertCell()
                cell.classList.add('warehouse')
                cell.classList.add('no-print')
                warehouseColumnIndex = cell.cellIndex
                cell.setAttribute('row-idx', row.rowIndex)
                cell.setAttribute('col-idx', warehouseColumnIndex)

            }

            // mark not available hours of teacher
            for (let i = 0; i < teachersArray.length; i++) {
                const colsNA = teachersArray[i].colsNA
                if (colsNA) {
                    colsNA.forEach(c => {
                        cell = table.tBodies[0].rows[i].cells[c]
                        cell.classList.add("not-av")
                    })
                }
            }

            // insert activities
            for (let i = 0; i < objActivitiesStartTimes.length; i++) {
                // get cell
                row = table.rows[objActivitiesStartTimes[i].r]
                cell = row.cells[objActivitiesStartTimes[i].c]

                // delete from activities if is set objActivitiesStartTimes
                delete objAct[objActivitiesStartTimes[i].id]

                // create the cards (spans)
                const tmimaSpan = document.createElement("span");
                tmimaSpan.setAttribute("class", "drag-span display-inline-block");
                tmimaSpan.id = objActivitiesStartTimes[i].id;
                tmimaSpan.setAttribute("teacher", objActivitiesStartTimes[i].data.teacherStr);
                tmimaSpan.setAttribute("tmima", objActivitiesStartTimes[i].data.tmimata);
                objActivitiesStartTimes[i].data.room ? tmimaSpan.setAttribute("room", objActivitiesStartTimes[i].data.room) : false
                tmimaSpan.setAttribute("row", row.rowIndex - thead.childElementCount)
                tmimaSpan.setAttribute("col", cell.cellIndex);
                tmimaSpan.innerHTML = `<span class="top-span display-none" style="font-size:${initFontSize}">` + objActivitiesStartTimes[i].data.subject + '</span>' + '<span class="bottom-span">' + objActivitiesStartTimes[i].data.tmima + '</span>' + `<span class="top-span display-none" style="font-size:${initFontSize}">` + (objActivitiesStartTimes[i].data.room ? "\n" + objActivitiesStartTimes[i].data.room : '');
                tmimaSpan.setAttribute('info', objActivitiesStartTimes[i].data.tmima + " - " + objActivitiesStartTimes[i].data.duration + '/' + objActivitiesStartTimes[i].data.totalDuration + "\n" + objActivitiesStartTimes[i].data.subject + "\n" + objActivitiesStartTimes[i].data.teacherStr + (objActivitiesStartTimes[i].data.room ? "\n" + objActivitiesStartTimes[i].data.room : ''))
                tmimaSpan.draggable = true;
                if (showColors) tmimaSpan.style.background = objActivitiesStartTimes[i].color
                // add card to cell
                cell.appendChild(tmimaSpan)
                // set data to cell
                cell.id = objActivitiesStartTimes[i].id
                cell.setAttribute('tmima', objActivitiesStartTimes[i].data.tmimata)
                cell.setAttribute('teacher', objActivitiesStartTimes[i].data.teacher)
                objActivitiesStartTimes[i].data.room ? cell.setAttribute("room", objActivitiesStartTimes[i].data.room) : false

                // make cards wide to simulate duration
                // all cards have duration 1
                tmimaSpan.setAttribute("w", 1);
                tmimaSpan.setAttribute("day", cell.getAttribute('day'))
                tmimaSpan.setAttribute("hour", cell.getAttribute('hour'))


                // if duration > 1 set width
                clspn = objActivitiesStartTimes[i].data.duration
                if (clspn > 1) {
                    tmimaSpan.classList.add("w-" + clspn)
                    tmimaSpan.setAttribute("w", clspn);
                    tmimaSpan.setAttribute("hour", tmimaSpan.getAttribute("hour") + '-' + getKeyByValue(hoursIndexList, parseInt(hoursIndexList[cell.getAttribute('hour')]) + parseInt(clspn) - 1))

                    index = cell.cellIndex
                    for (j = 0; j < clspn; j++) {
                        // set group to all cells that occupies the card
                        row.cells[index + j].id = objActivitiesStartTimes[i].id
                        // set start - stop indexes for loop through cells
                        // a triple wide card occupies three cells
                        // cell 1  => start = 0,  stop = 2
                        // cell 2  => start = -1, stop = 1
                        // cell 3 => start = -2,  stop = 0
                        // that way i know in which cell the card belongs
                        row.cells[index + j].setAttribute('tmima', objActivitiesStartTimes[i].data.tmimata)
                        row.cells[index + j].setAttribute('teacher', objActivitiesStartTimes[i].data.teacher)
                        if (objActivitiesStartTimes[i].data.room) row.cells[index + j].setAttribute('room', objActivitiesStartTimes[i].data.room)
                        row.cells[index + j].setAttribute('start', 0 - j)
                        row.cells[index + j].setAttribute('stop', clspn - 1 - j)
                    }

                }
            }

            // if Activities left in objAct means that 
            // these activities have no preferedStartingTime
            // so they must be put to warehouse
            for (let index of Object.keys(objAct)) {
                for (i = 0; i < objAct[index].teacher.length; i++) {
                    // create the cards (spans)
                    let tmimaSpan = document.createElement("span");
                    tmimaSpan.setAttribute("class", "drag-span display-inline-block");
                    tmimaSpan.id = index;
                    tmimaSpan.setAttribute("teacher", objAct[index].teacherStr);
                    tmimaSpan.setAttribute("tmima", objAct[index].tmimata);
                    objAct[index].room ? tmimaSpan.setAttribute("room", objAct[index].room) : false
                    const idx = teachersArray.findIndex(t => t.name == objAct[index].teacher[i])
                    tmimaSpan.setAttribute("row", idx);
                    tmimaSpan.setAttribute("col", warehouseColumnIndex);
                    tmimaSpan.innerHTML = `<span class="top-span display-none" style="font-size:${initFontSize}">` + objAct[index].subject + '</span>' + '<span class="bottom-span">' + objAct[index].tmima + '</span>' + `<span class="top-span display-none" style="font-size:${initFontSize}">` + (objAct[index].room ? "\n" + objAct[index].room : '');
                    tmimaSpan.setAttribute('info', objAct[index].tmima + " - " + objAct[index].duration + '/' + objAct[index].totalDuration + "\n" + objAct[index].subject + "\n" + objAct[index].teacherStr + (objAct[index].room ? "\n" + objAct[index].room : ''))
                    tmimaSpan.draggable = true;
                    if (showColors) tmimaSpan.style.background = teachersArray[idx]?.color
                    tmimaSpan.setAttribute("w", 1);
                    // if duration > 1 set width
                    clspn = objAct[index].duration
                    if (clspn > 1) {
                        tmimaSpan.classList.add("w-" + clspn)
                        tmimaSpan.setAttribute("w", clspn);
                    }
                    // add card to cell
                    tbody.rows[tmimaSpan.getAttribute('row')].cells[warehouseColumnIndex].appendChild(tmimaSpan)

                }

            }

            eventListeners()
            saveTable(table)
        }

        // add eventListeners
        // should appended every time reconstruct table from history
        function eventListeners() {
            const table = document.getElementById('programTable')
            table.addEventListener('dragover', handleDragOver);
            table.addEventListener('drop', handleDrop);

            const spans = Array.from(document.querySelectorAll(`.drag-span`))
            spans.forEach(sp => {
                sp.addEventListener('dragstart', handleDragStart);
                sp.addEventListener('dragend', handleDragEnd);
                sp.ondblclick = () => handleDoubleClick(sp)
                sp.onmouseover = function () {
                    document.getElementById('whiteboard').innerText = this.getAttribute('info') ? this.getAttribute('info').replace(', ', '\n') : '';
                    document.getElementById('whiteboard').classList.remove('display-none');
                };
                sp.onmouseout = function () {
                    document.getElementById('whiteboard').innerText = '';
                    document.getElementById('whiteboard').classList.add('display-none');
                };
            })

            const teacherNameCells = Array.from(document.querySelectorAll(`.teacher-name`))
            teacherNameCells.forEach(c => {
                c.addEventListener('click', () => teacherNoPrint(c))
            })

            const dayRowCells = Array.from(document.querySelectorAll(`.day`))
            dayRowCells.forEach(d => {
                d.addEventListener('click', () => dayNoPrint(d))
            })

            const hourColCells = Array.from(document.querySelectorAll(`.hour`))
            hourColCells.forEach(c => {
                c.onmouseover = function () {
                    document.getElementById('whiteboard').innerText = this.getAttribute('info') ? this.getAttribute('info').replace(', ', '\n') : '';
                    document.getElementById('whiteboard').classList.remove('display-none');
                };
                c.onmouseout = function () {
                    document.getElementById('whiteboard').innerText = '';
                    document.getElementById('whiteboard').classList.add('display-none');
                };
            })

            // clear backgrounds might be present ( and saved) when table was saved
            const spotLastCell = Array.from(document.querySelectorAll('.spot-last-cell'))
            spotLastCell.forEach(c => c.classList.remove('spot-last-cell'))

            const spotExpelled = Array.from(document.querySelectorAll('.spot-expelled'))
            spotExpelled.forEach(c => c.classList.remove('spot-expelled'))

            const highlighted = Array.from(document.querySelectorAll('.highlight'))
            highlighted.forEach(c => c.classList.remove('highlight'))

            markBorder()
            findMissingTmimata()
        }

        // saves table to sessionStorage
        function saveTable(table) {

            // set variables to session to track indexes
            const keepTables = sessionStorage.getItem("keep-tables")
            let first = sessionStorage.getItem("first-table-index")
            const last = sessionStorage.getItem("last-table-index")
            const current = sessionStorage.getItem("current-table-index")

            // if isset keepTables and the number of entries > keepTables remove items from beggining of stack
            if (keepTables) {
                if (last - first > keepTables) {
                    sessionStorage.removeItem('table#' + first)
                    first++
                    sessionStorage.setItem('first-table-index', first)
                }
            } else {
                sessionStorage.setItem('first-table-index', 0)
            }

            // calculate newIndex
            let newIndex = 0
            if (current) {
                newIndex = +current + +1
            }

            // save table
            // if memory is full it will throw error
            try {
                const tableJson = serializeDOM(table)
                sessionStorage.setItem('table#' + newIndex, JSON.stringify(tableJson))
                // set index after table saved
                // if memory full program throws exception in previous line so the indexes won't change
                sessionStorage.setItem('current-table-index', newIndex)
                sessionStorage.setItem('last-table-index', newIndex)
            } catch {
                // memory full
                // set keepTables to safe num newIndex - 2
                sessionStorage.setItem('keep-tables', newIndex - 2)
            }

            // if we are back in history and make new moves of cards
            // we delete all history after last current history
            if (newIndex !== last) {
                for (i = last; i > newIndex; i--) {
                    sessionStorage.removeItem('table#' + i)
                }
            }
            showHidePrevNext()
        }

        //  Determine if a color is a light color
        //  @see https://gist.github.com/krabs-github/ec56e4f1c12cddf86ae9c551aa9d9e04
        function isLightColor(color) {
            let r, g, b;

            // Check the format of the color, HEX or RGB?
            if (color.match(/^rgb/)) {
                // If HEX --> store the red, green, blue values in separate variables
                const rgb = color.match(
                    /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/
                );

                r = rgb[1];
                g = rgb[2];
                b = rgb[3];
            } else {
                // If RGB --> Convert it to HEX: http://gist.github.com/983661
                const hexColor = +(
                    '0x' + color.slice(1).replace(color.length < 5 && /./g, '$&$&')
                );

                r = hexColor >> 16;
                g = (hexColor >> 8) & 255;
                b = hexColor & 255;
            }

            // HSP equation from http://alienryderflex.com/hsp.html
            const hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));

            // Using the HSP value, determine whether the color is light or dark
            // > 127.5 is 'light', <= 127.5 is 'dark'

            //return hsp > 127.5;
            return hsp > 150;
        }

        function handleDragStart(e) {
            draggedElement = e.target;
            document.querySelectorAll(`span[id="${draggedElement.id}"]`).forEach(sp => {
                sp.classList.add('dragging');
            })
            e.dataTransfer.effectAllowed = 'move';
            // set background green at allowed for drop row
            setBackgroundGreen(draggedElement)
            // change drag status of cards so i can target in background cells
            const spans = Array.from(document.querySelectorAll(`.drag-span`))
            spans.forEach(el => {
                if (el.id !== draggedElement.id) el.classList.add('no-drag')
            })
        }

        function handleDragEnd(e) {
            document.querySelectorAll(`span[id="${draggedElement.id}"]`).forEach(sp => {
                sp.classList.remove('dragging');
            })
            draggedElement.classList.remove('dragging');
            // set card drag status to default
            const spans = Array.from(document.querySelectorAll(`.drag-span`))
            spans.forEach(el => el.classList.remove('no-drag'))

            whiteboard.innerText = ''
            whiteboard.classList.add('display-none');
            whiteboard.animate({
                left: `50%`,
                top: `5px`
            }, { duration: 10, fill: "forwards" })

            removeBackground(draggedElement)

        }

        function handleDragOver(e) {
            e.preventDefault();
            // highlight closer cell for drop
            const { clientX, clientY } = e
            const cell = e.target.closest('td');
            cell.classList.add('highlight');
            setTimeout(() => cell.classList.remove('highlight'), 200);

            const affectedCells = getAffectedCells(cell)
            const affectedSpans = getAffectedSpans(affectedCells)
            const message = getMessage(cell, affectedSpans)

            if (message.length) {
                whiteboard.classList.remove('display-none')
                whiteboard.innerText = message
                whiteboard.animate({
                    left: `${clientX + 20 + whiteboard.offsetWidth / 2}px`,
                    top: clientY > window.innerHeight / 2 ? `${clientY - whiteboard.offsetHeight - 20}px` : `${clientY + 20}px`
                }, { duration: 500, fill: "forwards" })
            } else {
                whiteboard.classList.add('display-none')
            }

            if (!allowDrop(cell)) e.dataTransfer.dropEffect = 'none'

        }

        // clean things after drop
        function clearElement(el) {
            el.classList.remove('dragging');
            el = null;
        }

        function allowDrop(cell) {
            const dragElId = draggedElement.id
            const dragElSize = draggedElement.getAttribute('w')
            const cellId = +cell.id + +cell.getAttribute('start')
            const columnIndex = cell.getAttribute('col-idx')

            // if drop is in the old cell that drag started i do nothing
            if (dragElId == cellId) {
                return false
            }

            // if card size is 2 or 3 i prevent droping in last hours
            let lastHoursAllowance = columnIndex % hoursLength
            if (lastHoursAllowance == 0) {
                lastHoursAllowance = 1
            } else {
                lastHoursAllowance = hoursLength - lastHoursAllowance + 1
            }
            if (dragElSize > lastHoursAllowance) {
                return false
            }
            return true
        }

        function getAffectedCells(cell) {

            const dragElTmima = draggedElement.getAttribute('tmima').split(',')
            const dragElRoom = draggedElement.getAttribute('room')
            const dragElTeacher = draggedElement.getAttribute('teacher')
            const dragElRow = draggedElement.getAttribute('row')
            const dragElSize = draggedElement.getAttribute('w')
            const columnIndex = cell.getAttribute('col-idx')
            // find row/rows of draggedElement/draggedElements
            const draggedSpansRows = Array.from(document.querySelectorAll(`span[id="${draggedElement.id}"]`)).map(el => el.getAttribute('row'))

            if (!allowDrop(cell)) return []

            // add subgroups or parent group to affected groups
            let affectedElTmimata = [...dragElTmima]
            if (xmlGroupsArray[dragElTmima] !== undefined) affectedElTmimata = [...affectedElTmimata, ...xmlGroupsArray[dragElTmima]]
            if (subgroupsArray[dragElTmima] !== undefined) affectedElTmimata = [...affectedElTmimata, ...subgroupsArray[dragElTmima]]

            // keep values of affectedElTmimata only once ( unique)
            affectedElTmimata = Array.from(new Set(affectedElTmimata))

            let affectedCells = []
            for (i = 0; i < dragElSize; i++) {
                const moreCells = Array.from(document.querySelectorAll(`td[col-idx="${+columnIndex + i}"]`))
                    .filter(c =>
                        intersects(c.getAttribute('tmima')?.split(','), affectedElTmimata) || // same groups
                        (dragElRoom && c.getAttribute('room') == dragElRoom) || // same room
                        (dragElTeacher && intersects(c.getAttribute('teacher')?.split(','), dragElTeacher?.split(','))) || // same teacher
                        draggedSpansRows.includes(c.getAttribute('row-idx')) // overlap in same row
                    )
                affectedCells = [...affectedCells, ...moreCells]
            }

            affectedCells = affectedCells.sort((a, b) => parseInt(a.getAttribute('hour')) > parseInt(b.getAttribute('hour'))).sort((a, b) => parseInt(a.getAttribute('row')) > parseInt(b.getAttribute('row')))
            return affectedCells
        }


        function getAffectedSpans(affectedCells) {
            let affectedSpans = []
            affectedCells.forEach(c => {
                if (c.firstChild) {
                    affectedSpans.push(c.firstChild)
                } else {
                    if (document.querySelector(`span[id="${c.id}"]`)) affectedSpans.push(document.querySelector(`span[id="${c.id}"]`))
                }
            })
            return affectedSpans
        }

        function getMessage(cell, affectedSpans) {

            let dropHour = cell.getAttribute('hour')?.replace(/[^0-9]/g, "")
            let dragHour = draggedElement.parentElement.getAttribute('hour')?.replace(/[^0-9]/g, "")
            if (draggedElement.getAttribute('w') > 1) {
                if (dragHour) {
                    dragStopHour = +dragHour + +draggedElement.getAttribute('w') - 1
                    dragHour = getOrdinal(dragHour) + ' - ' + getOrdinal(dragStopHour)
                }
                dropStopHour = +dropHour + +draggedElement.getAttribute('w') - 1
                dropHour = getOrdinal(dropHour) + ' - ' + getOrdinal(dropStopHour)
            } else {
                if (dragHour) dragHour = getOrdinal(dragHour)
                dropHour = getOrdinal(dropHour)
            }

            const dragElTmima = draggedElement.getAttribute('tmima').split(',')
            const dragElRoom = draggedElement.getAttribute('room')
            const dragElTeacher = draggedElement.getAttribute('teacher')

            // creating message for user checking what should do at 2nd round
            let message = []
            let finalMessage = ''

            affectedSpans.forEach(el => {
                const apo = +el.parentElement.getAttribute('hour').replace(/[^0-9]/g, "") + +el.parentElement.getAttribute('start')
                const eos = +el.parentElement.getAttribute('hour').replace(/[^0-9]/g, "") + +el.parentElement.getAttribute('stop')
                const oraStr = apo ? apo == eos ? getOrdinal(apo) + ' hour' : getOrdinal(apo) + ' to ' + getOrdinal(eos) + ' hours' : '';
                message.push('\n' + (oraStr ? oraStr + '\n' : '') + el.parentElement.parentElement.cells[0].textContent + '\ngroup:    ' + el.getAttribute('tmima') + (el.getAttribute('room') ? '\nroom:     ' + el.getAttribute('room') : '') + '\n')
            })

            // get unique messages of array 
            message = Array.from(new Set(message))

            if (message.length) {
                headMessage = `Moved activity\n\n` + (dragHour ? `${dragHour} hour\n` : '') + `${dragElTeacher}\ngroup:    ${dragElTmima}\n` + (dragElRoom ? `room:     ${dragElRoom}\n` : '') + (dragHour ? `\nfrom ${dragHour} ` : '\n') + `to ${dropHour} hour conflicts with\n`
                finalMessage = headMessage + message.join("")
            }

            return finalMessage
        }

        function handleDrop(e) {
            e.preventDefault();

            const cell = e.target.closest('td');
            if (!(cell && draggedElement)) { return }

            const table = cell.parentElement.parentElement.parentElement

            const columnIndex = cell.getAttribute('col-idx')
            const tbody = cell.parentElement.parentElement
            const rowsLegth = tbody.rows.length

            const dragElId = draggedElement.id
            const dragElTmima = draggedElement.getAttribute('tmima').split(',')
            const dragElRoom = draggedElement.getAttribute('room')
            const dragElSize = draggedElement.getAttribute('w')
            const dragElTeacher = draggedElement.getAttribute('teacher')


            // set card drag status to default
            const spans = Array.from(document.querySelectorAll(`.drag-span`))
            spans.forEach(el => el.classList.remove('no-drag'))

            // find conflicting cards
            const affectedCells = getAffectedCells(cell)
            const affectedSpans = getAffectedSpans(affectedCells)
            const message = getMessage(cell, affectedSpans)

            // ask user to confirm
            if (message) {
                var ok = confirm(message + '\nPlease confirm substitution.')
                if (!ok) {
                    // removeBackground(draggedElement)
                    return
                }
            }

            // clean all old cells of the dragged card 
            const cellsClear = Array.from(document.querySelectorAll(`td[id="${dragElId}"]`))
            cellsClear.forEach(el => {
                el.removeAttribute('id')
                el.removeAttribute('tmima')
                el.removeAttribute('room')
                el.removeAttribute('teacher')
                el.removeAttribute('start')
                el.removeAttribute('stop')
                el.classList.add('spot-last-cell');
                setTimeout(() => el.classList.remove('spot-last-cell'), spotExpellDuration);
            })

            // send affected cards to ware house
            affectedSpans.forEach(span => {
                if (!span) return
                document.querySelectorAll(`span[id="${span.id}"]`).forEach(sp => {
                    sp.setAttribute('col', warehouseColumnIndex)
                    sp.removeAttribute('day')
                    sp.removeAttribute('hour')
                    tbody.rows[sp.getAttribute('row')].cells[warehouseColumnIndex].appendChild(sp)
                })
            })

            //clean affected cells
            affectedCells.forEach(c => {
                const cellsClear = document.querySelectorAll(`td[id="${c.id}"]`)
                cellsClear.forEach(td => {
                    td.removeAttribute('id')
                    td.removeAttribute('tmima')
                    td.removeAttribute('room')
                    td.removeAttribute('teacher')
                    td.removeAttribute('start')
                    td.removeAttribute('stop')
                    td.classList.add('spot-expelled');
                    setTimeout(() => td.classList.remove('spot-expelled'), spotExpellDuration);
                })
            })

            // append the card to drop cell and setAttibutes to cells
            document.querySelectorAll(`span[id="${dragElId}"]`).forEach(sp => {
                const currentRow = sp.getAttribute('row')
                tbody.rows[sp.getAttribute('row')].cells[columnIndex].appendChild(sp)
                sp.setAttribute('col', columnIndex)

                let chkNotAvailableCells = false
                for (i = 0; i < dragElSize; i++) {
                    const workingCell = tbody.rows[currentRow].cells[+columnIndex + i]
                    workingCell.id = dragElId
                    workingCell.setAttribute('tmima', dragElTmima)
                    workingCell.setAttribute('room', dragElRoom)
                    workingCell.setAttribute('teacher', dragElTeacher)
                    if (workingCell.classList.contains('not-av')) { chkNotAvailableCells = true }
                }

                // mark card if droped in not available teacher time cell
                if (chkNotAvailableCells) {
                    sp.classList.add('warn-span')
                } else {
                    sp.classList.remove('warn-span')
                }
            })

            // removeBackground(draggedElement)
            clearElement(draggedElement)

            findMissingTmimata()
            saveTable(table)
        }

        function findMissingTmimata() {
            const table = document.getElementById('programTable')

            // find missing groups for every column
            for (i = 1; i < table.tBodies[0].rows[0].cells.length - 1; i++) {
                // start with full group array for every column
                let colGroupsArray = groupsArray

                /* 
                I DONT NEED THIS NOW. 
                JUST LEAVE THE CODE IF IS NEEDED IN FUTURE

                // find all groups in current hour
                let tmimataArr = []
                */

                // find all rooms occupied in current hour
                let roomsArr = []
                // at every row
                for (j = 0; j < table.tBodies[0].rows.length; j++) {
                    // get group
                    let toRemove = table.tBodies[0].rows[j].cells[i].getAttribute('tmima')
                    let rooms = table.tBodies[0].rows[j].cells[i].getAttribute('room')

                    // if group present i remove it from arraycolGroupsArray
                    if (toRemove) {

                        toRemove = toRemove.split(',')

                        /* I DONT NEED THIS NOW 
                        tmimataArr = [...tmimataArr, ...toRemove]
                        */

                        // add rooms to array if availiable
                        if (rooms) roomsArr = [...roomsArr, rooms]

                        colGroupsArray = colGroupsArray.filter((el) => !toRemove.includes(el));

                        for (k = 0; k < toRemove.length; k++) {
                            // if current group is Subgroup i also remove parent Group
                            if (subgroupsArray[toRemove[k]]) {
                                colGroupsArray = colGroupsArray.filter((el) => !subgroupsArray[toRemove[k]].includes(el));
                            }
                            // if current group has Subgroups i also remove these Subgroups
                            if (xmlGroupsArray[toRemove[k]]) {
                                colGroupsArray = colGroupsArray.filter((el) => !xmlGroupsArray[toRemove[k]].includes(el));
                            }
                        }

                    }

                }

                /* I DONT NEED THIS NOW 
                table.tFoot.rows[0].cells[i].setAttribute('tmimata', Array.from(new Set(tmimataArr)))
                */

                // set rooms in footer to check if occupied at current hour
                table.tFoot.rows[0].cells[i].setAttribute('rooms', Array.from(new Set(roomsArr)))

                // if groups left in array set thead and tfoot to inform user
                if (colGroupsArray.length) {
                    if (showFooter) {
                        table.tHead.rows[1].cells[i - 1].style.background = '#eeeeee'
                        table.tHead.rows[1].cells[i - 1].setAttribute('info', 'groups with no activity\n' + colGroupsArray)
                    } else {
                        table.tHead.rows[1].cells[i - 1].style.background = ''
                        table.tHead.rows[1].cells[i - 1].setAttribute('info', '')
                    }
                    table.tFoot.rows[0].cells[i].innerHTML = colGroupsArray.sort().join('<br>')
                } else {
                    table.tHead.rows[1].cells[i - 1].style.background = ''
                    table.tHead.rows[1].cells[i - 1].setAttribute('info', '')
                    table.tFoot.rows[0].cells[i].textContent = ''
                }
            }

        }

        // swaps print-noprint for specific day
        function dayNoPrint(day) {
            const table = day.parentElement.parentElement.parentElement

            if (day.classList.contains('strike')) {

                day.classList.remove('no-print')
                day.classList.remove('strike')
                day.title = 'Do not print'
                for (i = 0; i < hoursLength; i++) {
                    table.tHead.rows[1].cells[(day.cellIndex - 1) * hoursLength + i].classList.remove('no-print')
                    for (j = 0; j < table.tBodies[0].children.length; j++) {
                        table.tBodies[0].rows[j].cells[(day.cellIndex - 1) * hoursLength + i + 1].classList.remove('no-print')
                    }
                }

            } else {

                day.classList.add('no-print')
                day.classList.add('strike')
                day.title = 'Do print'
                for (i = 0; i < hoursLength; i++) {
                    table.tHead.rows[1].cells[(day.cellIndex - 1) * hoursLength + i].classList.add('no-print')
                    for (j = 0; j < table.tBodies[0].children.length; j++) {
                        table.tBodies[0].rows[j].cells[(day.cellIndex - 1) * hoursLength + i + 1].classList.add('no-print')
                    }
                }
            }

        }

        // sends card to warehouse
        function handleDoubleClick(el) {
            if (el.getAttribute('col') == warehouseColumnIndex) return
            const tbody = el.parentElement.parentElement.parentElement
            const table = tbody.parentElement
            const existingElements = Array.from(document.querySelectorAll(`span[id="${el.id}"]`))
            existingElements.forEach(el => {
                el.setAttribute('col', warehouseColumnIndex)
                el.classList.remove('warn-span')
                tbody.rows[el.getAttribute('row')].cells[warehouseColumnIndex].appendChild(el)
            })
            const existingElementsCells = Array.from(document.querySelectorAll(`td[id="${el.id}"]`))
            existingElementsCells.forEach(el => {
                el.removeAttribute('id')
                el.removeAttribute('tmima')
                el.removeAttribute('teacher')
                el.removeAttribute('room')
                el.removeAttribute('start')
                el.removeAttribute('stop')
                el.classList.add('spot-expelled');
                setTimeout(() => el.classList.remove('spot-expelled'), spotExpellDuration);
            })

            findMissingTmimata()
            saveTable(table)
        }


        // source: https://blog.stackademic.com/understanding-dom-serialization-and-parsing-in-javascript-28e8ec1acab3
        const serializeDOM = (root) => {
            if (!(root instanceof Element)) return null; // Ensure the element is a valid DOM element
            const domList = {
                childNodes: [],
                type: "element",
                tagName: root.tagName, // Get the tag name (e.g., div, p, h1)
            };
            // Loop through all the attributes of the element and add them to the serialized object
            for (const attr of root.attributes) {
                domList[attr.name] = `${attr.value}`;
            }
            // Recursively serialize child elements
            root.childNodes.forEach((node) => {
                if (node.nodeType === 1) {
                    domList.childNodes.push(serializeDOM(node)); // Serialize child elements
                } else if (node.nodeType === 3 && node.nodeValue.trim() !== "") {
                    // Serialize text nodes, but ignore empty text nodes
                    domList.childNodes.push({
                        type: "text",
                        content: node.nodeValue, // Store the content of the text node
                    });
                }
            });
            return domList; // Return the serialized DOM
        };

        // source: https://blog.stackademic.com/understanding-dom-serialization-and-parsing-in-javascript-28e8ec1acab3
        const parseDOM = (element) => {
            const { type } = element;
            if (type === "text") {
                // If it's a text node, create a text node
                const rootEle = document.createTextNode(element.content);
                return rootEle;
            }
            const { tagName, childNodes, ...props } = element;
            const rootEle = document.createElement(tagName.toLowerCase()); // Create the element based on the tag name
            // Set attributes of the element
            for (let prop of Object.keys(props)) {
                if (prop.startsWith("on")) {
                    // Handle inline event listeners
                    rootEle[prop] = new Function(props[prop]);
                } else {
                    rootEle.setAttribute(prop, props[prop]);
                }
            }
            // Recursively append child nodes
            childNodes.forEach((node) => {
                rootEle.appendChild(parseDOM(node)); // Recursively parse child elements
            });
            return rootEle; // Return the recreated DOM element
        };

        function prev() {
            let current = sessionStorage.getItem("current-table-index")
            const first = sessionStorage.getItem("first-table-index")
            if (current == first) { return }
            current--
            sessionStorage.setItem("current-table-index", current)
            const tableJson = sessionStorage.getItem('table#' + current)
            const newTable = parseDOM(JSON.parse(tableJson))
            const oldTable = document.getElementById('programTable')
            document.getElementById('tablediv').replaceChild(newTable, oldTable)

            eventListeners()
            showHidePrevNext()
            doToggleFooter()
        }

        function next() {
            let current = sessionStorage.getItem("current-table-index")
            const last = sessionStorage.getItem("last-table-index")
            if (current == last) { return }
            current++
            sessionStorage.setItem("current-table-index", current)
            const tableJson = sessionStorage.getItem('table#' + current)
            const newTable = parseDOM(JSON.parse(tableJson))
            const oldTable = document.getElementById('programTable')
            document.getElementById('tablediv').replaceChild(newTable, oldTable)

            eventListeners()
            showHidePrevNext()
            doToggleFooter()
        }

        function showHidePrevNext() {
            const first = sessionStorage.getItem("first-table-index")
            const last = sessionStorage.getItem("last-table-index")
            const current = sessionStorage.getItem("current-table-index")
            if (current == last) {
                document.getElementById('next').style.visibility = 'hidden'
            } else {
                document.getElementById('next').style.visibility = 'visible'
            }
            if (current == first) {
                document.getElementById('prev').style.visibility = 'hidden'
            } else {
                document.getElementById('prev').style.visibility = 'visible'
            }
        }

        // Get the modal
        const aboutModal = document.getElementById("aboutModal");
        // Get the button that opens the modal
        const btn = document.getElementById("aboutBtn");
        // Get the <span> element that closes the modal
        const span = document.getElementsByClassName("close")[0];

        // When the user clicks the button, open the modal 
        btn.onclick = function () {
            aboutModal.style.display = "block";
        }

        function closeAbout() {
            aboutModal.style.display = 'none';
            //window.location.reload()
        }

        // When the user clicks on <span> (x), close the modal
        span.onclick = function () {
            closeAbout()
        }

        // Get the error modal
        const errorModal = document.getElementById('errorModal');

        function showError(title, message) {
            document.getElementById('errorTitle').textContent = title;
            document.getElementById('errorMessage').textContent = message;
            errorModal.style.display = 'block';
        }

        function closeError() {
            //errorModal.style.display = 'none';
            window.location.reload()
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            if (event.target === aboutModal) {
                closeAbout();
            }
            if (event.target === errorModal) {
                closeError();
            }
        }

        // Close with ESC key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && aboutModal.style.display === 'block') {
                closeAbout();
            }
            if (event.key === 'Escape' && errorModal.style.display === 'block') {
                closeError();
            }
        });

        function toggleFooterVisible() {
            showFooter = !showFooter
            doToggleFooter()
        }

        function doToggleFooter() {
            const toggleFooter = document.getElementById('toggleFooter')
            let allFootCells = Array.from(document.querySelectorAll(`.footer`))
            allFootCells.forEach(c => {
                if (showFooter) {
                    c.classList.remove('display-none')
                    toggleFooter.title = "Toggle footer invisible"
                    toggleFooter.innerHTML = "&otimes;"
                } else {
                    c.classList.add('display-none')
                    toggleFooter.title = "Toggle footer visible"
                    toggleFooter.innerHTML = "&oplus;"
                }
            })
            findMissingTmimata()
        }

        function setTitle() {
            let title = prompt('Input title to be printed', document.getElementById('title').textContent)
            if (title == null) return
            if (!title.trim()) return
            document.getElementById('title').textContent = title.trim();
        }

        function markBorder() {
            const markBorder = Array.from(document.querySelectorAll(`.mark-border`))
            markBorder.forEach(el => {
                //if (document.documentElement.hasAttribute('dir')) {
                if (document.getElementById('tablecontainer').hasAttribute('dir')) {
                    el.style.borderLeftWidth = 'medium';
                    el.style.borderRightWidth = 'thin';
                } else {
                    el.style.borderRightWidth = 'medium';
                    el.style.borderLeftWidth = 'thin';
                }
            })
        }

        function changeDirection() {
            const direction = localStorage.getItem("direction")
            if (!direction) {
                localStorage.setItem("direction", 'rtl')
                document.getElementById('tablecontainer').setAttribute('dir', 'rtl')
            } else {
                // document.documentElement.removeAttribute('dir')
                document.getElementById('tablecontainer').removeAttribute('dir')
                localStorage.removeItem("direction")
                document.getElementById('prev').innerHTML = '&larr;'
                document.getElementById('next').innerHTML = '&rarr;'
            }
            markBorder()
        }

        // show/hide top-span with subject
        function showSubject() {
            // get all top-spans of cards that show subject
            const topSpans = Array.from(document.querySelectorAll(`.top-span`))
            topSpans.forEach(el => {
                if (el.classList.contains('display-none')) {
                    // make them visible and vertcal align bottom
                    el.classList.remove('display-none')
                    el.classList.add('display-block')
                    //el.parentElement.parentElement.style.verticalAlign = 'bottom'
                } else {
                    // make them invisible and vertical align middle
                    el.classList.remove('display-block')
                    el.classList.add('display-none')
                    el.style.fontSize = initFontSize
                    //el.parentElement.parentElement.style.verticalAlign = 'middle'
                }
            })

        }

        // add click eventListener to button [...]

        // check if clicked left - center - right
        // if center show/hide top-span with subject
        // if left reduce subject font-size
        // if right enlarge subject font-size
        const showSubjectDiv = document.getElementById('showSubject');
        showSubjectDiv.addEventListener('click', (event) => {
            // Get the bounding rectangle of the div
            const rect = showSubjectDiv.getBoundingClientRect();
            // Calculate the center X-coordinate of the div
            const leftX = rect.left + rect.width / 4;
            const rightX = rect.right - rect.width / 4;
            // Get the X-coordinate of the click
            const clickX = event.clientX;

            const topSpans = Array.from(document.querySelectorAll(`.top-span`))
            // Determine if the click was on the left or right side
            if (clickX < leftX) {
                topSpans.forEach(el => {
                    el.style.fontSize = (parseFloat(el.style.fontSize) - 0.1) + 'rem'
                    if (el.classList.contains('display-none')) { showSubject() }
                })
            } else if (clickX > rightX) {
                topSpans.forEach(el => {
                    el.style.fontSize = (parseFloat(el.style.fontSize) + 0.1) + 'rem'
                    if (el.classList.contains('display-none')) { showSubject() }
                })
            } else {
                showSubject()
            }
        });


        window.onload = () => {

            if (localStorage.getItem("direction")) {
                document.getElementById('tablecontainer').setAttribute('dir', 'rtl')
            }
        }

        // clear session 
        window.onbeforeunload = () => sessionStorage.clear()

        function createSampleTable() {

            // create new sampleTable structure
            const sampleTable = document.createElement("table");
            // add class to easy access later
            sampleTable.classList.add('print-table')

            const header = document.getElementById("programTable").tHead.cloneNode(true)
            const days = Array.from(header.firstChild.children).slice(1, header.firstChild.children.length)
            const hours = Array.from(header.lastChild.children).slice(0, hoursLength)
            // create thead and add row and cells with hour names
            const head = sampleTable.appendChild(document.createElement('thead'))
            const row = head.insertRow()
            hours.forEach(h => {
                const cell = row.appendChild(h)
                cell.removeAttribute('style')
                cell.innerText = cell.title
            })
            // create tbody add rows and first cell with day names
            sampleTable.appendChild(document.createElement('tbody'))
            days.forEach(d => {
                const row = sampleTable.tBodies[0].insertRow()
                const cell = row.appendChild(d)
                cell.removeAttribute('style')
                cell.removeAttribute('colSpan')
                //cell.title = 'Do not print'
            })
            return sampleTable
        }

        // show and print schedule per teacher
        function printTeachersSchedule() {
            // get access to programTable
            const table = document.getElementById("programTable");
            // if table is not visible we make it visible
            if (table.classList.contains('display-none')) {
                table.classList.remove('display-none')
                // set buttons visible
                document.getElementById('printTeachers').title = 'Print Teachers Schedule'
                document.getElementById('printGroups').classList.remove('display-none')
                document.getElementById('printGroups').classList.add('display-inline-block')
                document.getElementById('toggleFooter').classList.remove('display-none')
                document.getElementById('toggleFooter').classList.add('display-inline-block')
                document.getElementById('prev').classList.remove('display-none')
                document.getElementById('prev').classList.add('display-inline-block')
                document.getElementById('next').classList.remove('display-none')
                document.getElementById('next').classList.add('display-inline-block')
                // remove all printTeacher tables
                const printTeacherTables = Array.from(document.querySelectorAll(`.print-table`))
                printTeacherTables.forEach(t => {
                    table.parentElement.removeChild(t)
                })
                // set css var --tile-width to default value
                document.documentElement.style.setProperty('--tile-width', tileWidth);
                // exit
                return
            }
            // table is visible. We make it invisible
            table.classList.add('display-none')
            // set buttons invisible
            document.getElementById('printTeachers').title = 'Back'
            document.getElementById('printGroups').classList.remove('display-inline-block')
            document.getElementById('printGroups').classList.add('display-none')
            document.getElementById('toggleFooter').classList.remove('display-inline-block')
            document.getElementById('toggleFooter').classList.add('display-none')
            document.getElementById('prev').classList.remove('display-inline-block')
            document.getElementById('prev').classList.add('display-none')
            document.getElementById('next').classList.remove('display-inline-block')
            document.getElementById('next').classList.add('display-none')

            // save original value of css var --tile-width to variable
            tileWidth = window.getComputedStyle(document.body).getPropertyValue('--tile-width')
            // calculate labelWidth
            const labelWidth = parseInt(tileWidth) * 5 + 'px'

            // get sampleTable
            tableTeachers = createSampleTable()

            //get all rows of programTable
            const tableRows = Array.from(table.tBodies[0].rows)
            // loop to create table for each teacher row
            tableRows.forEach(tr => {
                // get all cells of current row of programTable
                const tableRowCells = Array.from(tr.cells)

                // clone tableTeachers
                const newTable = tableTeachers.cloneNode(true)

                // insert first cell with name of teacher
                newTable.tHead.rows[0].insertBefore(tableRowCells[0].cloneNode(true), newTable.tHead.rows[0].firstChild)
                // set style and eventListener to first cell
                const cell = newTable.tHead.rows[0].cells[0]
                cell.removeAttribute('style')
                cell.style.fontWeight = 'bold'
                cell.style.minWidth = labelWidth
                cell.style.maxWidth = labelWidth
                cell.title = "Do not print"
                cell.style.cursor = 'pointer'
                cell.style.background = '#f5fbff'
                cell.style.color = '#11496e'
                cell.addEventListener('click', () => tableNoPrint(newTable))
                cell.classList.remove('strike')

                // remove first and last cell
                tableRowCells.shift()
                tableRowCells.pop()
                // loop tableRowCells and put them in correct row
                tableRowCells.forEach((trc, ind) => {
                    // row = ABS of division index ind / hoursLength
                    const rowInd = parseInt(ind / hoursLength)
                    // append cell to exact row
                    const cell = newTable.tBodies[0].rows[rowInd].appendChild(trc.cloneNode(true))
                    cell.removeAttribute('style')
                })

                // get fisrt column cells with day names
                // add classList to access them later and eventlistener to show-hide row when printing
                const rows = Array.from(newTable.tBodies[0].rows)
                rows.forEach(r => {
                    r.cells[0].classList.add('day-print-noprint')
                    r.cells[0].addEventListener('click', () => daysPrintNoprint(r.cells[0]))
                })

                // add table to DOM
                table.parentElement.appendChild(newTable)
            })

            markBorder()
            // set --tile-width for new tables to x4
            const newTileWidth = parseInt(tileWidth) * 4
            document.documentElement.style.setProperty('--tile-width', newTileWidth + 'px');
        }

        // swaps print-noprint for specific teacher table
        function tableNoPrint(table) {

            if (table.tHead.rows[0].cells[0].classList.contains('strike')) {
                table.classList.remove('no-print')
                table.tHead.rows[0].cells[0].classList.remove('strike')
                table.tHead.rows[0].cells[0].title = 'Do not print'
            } else {
                table.classList.add('no-print')
                table.tHead.rows[0].cells[0].classList.add('strike')
                table.tHead.rows[0].cells[0].title = 'Do print'
            }
        }

        // swaps print-noprint for teacher row in programtable
        function teacherNoPrint(cell) {
            if (cell.classList.contains('strike')) {
                cell.parentElement.classList.remove('no-print')
                cell.classList.remove('strike')
                cell.title = 'Do not print'
            } else {
                cell.parentElement.classList.add('no-print')
                cell.classList.add('strike')
                cell.title = 'Do print'
            }
        }

        function daysPrintNoprint(cell) {
            // get all days of printTeacherTables
            const days = Array.from(document.querySelectorAll(`.day-print-noprint`))
            const index = cell.parentElement.rowIndex
            days.forEach(d => {
                // if index is different continue to next
                if (d.parentElement.rowIndex !== index) return
                // toggle print - no-print
                if (d.classList.contains('strike')) {
                    d.classList.remove('strike')
                    d.title = 'Do not print'
                    d.parentElement.classList.remove('no-print')
                } else {
                    d.classList.add('strike')
                    d.title = 'Do print'
                    d.parentElement.classList.add('no-print')
                }
            })

        }

        function printGroupsSchedule() {
            // get access to programTable
            const table = document.getElementById("programTable");

            const tbltds = table.querySelectorAll('.program')

            // if table is not visible we make it visible
            if (table.classList.contains('display-none')) {
                table.classList.remove('display-none')
                // set buttons visible
                document.getElementById('printGroups').title = "Print Groups Schedule"
                document.getElementById('printTeachers').classList.remove('display-none')
                document.getElementById('printTeachers').classList.add('display-inline-block')
                document.getElementById('toggleFooter').classList.remove('display-none')
                document.getElementById('toggleFooter').classList.add('display-inline-block')
                document.getElementById('prev').classList.remove('display-none')
                document.getElementById('prev').classList.add('display-inline-block')
                document.getElementById('next').classList.remove('display-none')
                document.getElementById('next').classList.add('display-inline-block')
                // remove all printTeacher tables
                const printTeacherTables = Array.from(document.querySelectorAll(`.print-table`))
                printTeacherTables.forEach(t => {
                    table.parentElement.removeChild(t)
                })
                // set css var --tile-width to default value
                document.documentElement.style.setProperty('--tile-width', tileWidth);
                // exit
                return
            }
            // table is visible. We make it invisible
            table.classList.add('display-none')
            // set buttons invisible
            document.getElementById('printGroups').title = 'Back'
            document.getElementById('printTeachers').classList.remove('display-inline-block')
            document.getElementById('printTeachers').classList.add('display-none')
            document.getElementById('toggleFooter').classList.remove('display-inline-block')
            document.getElementById('toggleFooter').classList.add('display-none')
            document.getElementById('prev').classList.remove('display-inline-block')
            document.getElementById('prev').classList.add('display-none')
            document.getElementById('next').classList.remove('display-inline-block')
            document.getElementById('next').classList.add('display-none')

            // save original value of css var --tile-width to variable
            tileWidth = window.getComputedStyle(document.body).getPropertyValue('--tile-width')
            // calculate labelWidth
            const labelWidth = parseInt(tileWidth) * 3 + 'px' // !!! for a reason i dont know it does not work

            tableYears = createSampleTable()
            let cellColIdx = 0

            // loop to create table for each group
            //sortedUniqueArrGroups.forEach(tm => {
            groupsArray.forEach(tm => {
                // clone tableYears
                const newTable = tableYears.cloneNode(true)
                newTable.id = 'tbl@' + tm

                const newTableCells = Array.from(tbltds)
                    .filter(t => t.getAttribute('tmima')?.split(',').includes(tm))
                    .sort((a, b) => a.getAttribute('hour') > b.getAttribute('hour'))
                    .sort((a, b) => a.getAttribute('day') > b.getAttribute('day'))

                // insert first cell with name of Group
                const newCell = document.createElement('td')
                newTable.tHead.rows[0].insertBefore(newCell, newTable.tHead.rows[0].firstChild)
                // set innerText, style and eventListener to first cell
                const cell = newTable.tHead.rows[0].cells[0]
                cell.innerText = tm
                cell.classList.add('mark-border')
                cell.style.fontWeight = 'bold'
                cell.style.minWidth = labelWidth
                cell.style.maxWidth = labelWidth
                cell.title = "Do not print"
                cell.style.cursor = 'pointer'
                cell.style.background = '#f5fbff'
                cell.style.color = '#11496e'
                cell.style.textAlign = 'center'
                cell.addEventListener('click', () => tableNoPrint(newTable))

                // create other cells of table
                const rows = Array.from(newTable.tBodies[0].rows)
                rows.forEach((r, idx) => {
                    r.cells[0].classList.add('day-print-noprint')
                    r.cells[0].addEventListener('click', () => daysPrintNoprint(r.cells[0]))
                    r.cells[0].style.minWidth = labelWidth
                    r.cells[0].style.maxWidth = labelWidth
                    const rowCells = newTableCells.filter(c => c.getAttribute('day') == Object.keys(daysIndexList)[idx])

                    for (i = 0; i < hoursLength; i++) {
                        const cell = rowCells.filter(c => c.getAttribute('hour') == Object.keys(hoursIndexList)[i])[0]
                        if (cell) {
                            cellColIdx = cell.getAttribute('col-idx')
                            const newCell = cell.cloneNode(true)
                            r.appendChild(newCell)
                            if (newCell.firstChild) {
                                const newSp = newCell.firstChild
                                // set data to card spans
                                const info = newSp.getAttribute('info').split('\n')
                                newSp.firstChild.innerText = info[2].replace(' - ', '\n')
                                newSp.firstChild.classList.remove('display-none')
                                newSp.firstChild.style.fontSize = initFontSize
                                newSp.children[1].innerText = info[1]
                                newSp.children[1].style.fontSize = 'small'
                                newSp.lastChild.classList.remove('display-none')
                                newSp.lastChild.style.fontSize = initFontSize

                            }
                        } else {
                            const cell = r.insertCell()
                            cell.classList.add('program')
                            cell.setAttribute('col-idx', ++cellColIdx)
                            cell.setAttribute('day', Object.keys(daysIndexList)[idx])
                            cell.setAttribute('hour', Object.keys(hoursIndexList)[i])
                            if (i == hoursLength - 1) cell.classList.add('mark-border')
                        }

                    }
                })

                // add table to DOM
                table.parentElement.appendChild(newTable)
            })

            markBorder()
            // set --tile-width for new tables to x5
            const newTileWidth = parseInt(tileWidth) * 5
            document.documentElement.style.setProperty('--tile-width', newTileWidth + 'px');
        }

        function setTileWidth() {
            // save original value of css var --tile-width to variable
            tileWidth = window.getComputedStyle(document.body).getPropertyValue('--tile-width')
            let newTileWidth = prompt("Set width of cards in pixels. Default: 30", parseInt(tileWidth))
            if (!parseInt(newTileWidth)) return
            document.documentElement.style.setProperty('--tile-width', newTileWidth + 'px');
        }

        function getOrdinal(n) {
            let ord = 'th';
            if (n % 10 == 1 && n % 100 != 11) {
                ord = 'st';
            }
            else if (n % 10 == 2 && n % 100 != 12) {
                ord = 'nd';
            }
            else if (n % 10 == 3 && n % 100 != 13) {
                ord = 'rd';
            }
            return n + ord;
        }

        function intersects(a, b) {
            const s = new Set(b);
            return [...new Set(a)].some((x) => s.has(x));
        }

        function getKeyByValue(object, value) {
            return Object.keys(object).find(key => object[key] === value);
        }

    </script>

</body>

</html>
